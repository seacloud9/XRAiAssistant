<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Playground</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #1177bb;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .editor-container {
            width: 0%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease-in-out;
        }

        .editor-container.open {
            width: 100%;
        }

        .canvas-container {
            width: 100%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.3s ease-in-out;
        }

        .canvas-container.editor-open {
            width: 0%;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
        }
        
        .editor-toggle-btn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: #007acc;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 12px 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            z-index: 20;
            transition: all 0.3s ease-in-out;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .editor-toggle-btn:hover {
            background: #1177bb;
        }

        .editor-toggle-btn:active {
            background: #0e639c;
        }

        /* When editor is open, button moves to right edge */
        .editor-toggle-btn.editor-open {
            left: auto;
            right: 0;
            border-radius: 4px 0 0 4px;
        }
        
        .footer {
            background: #007acc;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        /* Floating Console Window */
        .console-window {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            background: #1e1e1e;
            border: 1px solid #007acc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            z-index: 2000;
            resize: both;
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            max-width: 90vw;
            max-height: 80vh;
        }

        .console-window.minimized {
            height: auto !important;
            min-height: auto;
            resize: none;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        .console-window.hidden {
            display: none;
        }

        .console-title-bar {
            background: #007acc;
            color: white;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .console-title {
            flex: 1;
        }

        .console-controls {
            display: flex;
            gap: 8px;
        }

        .console-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .console-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .console-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #ccc;
            background: #1e1e1e;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }

        .console-window.minimized .console-content {
            display: none;
        }

        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
            white-space: pre-wrap;
            user-select: text;
            -webkit-user-select: text;
        }

        .console-error {
            color: #f14c4c;
        }

        .console-warning {
            color: #ffcc02;
        }

        .console-log {
            color: #ccc;
        }

        .console-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #007acc 50%);
            opacity: 0.5;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        /* Console Open Button (always visible in editor) */
        .console-open-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .console-open-btn:hover {
            background: #1177bb;
            transform: scale(1.1);
        }

        .console-open-btn:active {
            background: #0e639c;
            transform: scale(0.95);
        }

        .console-open-btn.hidden {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        /* Remove media query - same behavior across all devices per requirements */
        /* The editor starts hidden (width: 0%) on all screen sizes */
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">▶ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">🗑 Clear</button>
        <button class="menu-btn" onclick="saveScene()">💾 Save</button>
        <button class="menu-btn" onclick="downloadScene()">⬇ Download</button>
        <button class="menu-btn" onclick="newScene()">📄 New</button>
        <button class="menu-btn" onclick="showExamples()">📚 Examples</button>
        <button class="menu-btn" onclick="toggleConsole()">🖥 Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Select Example...</option>
            <option value="basic-scene">Basic Scene</option>
            <option value="rotating-cube">Rotating Cube</option>
            <option value="lighting">Lighting Demo</option>
            <option value="materials">Materials Demo</option>
        </select>
    </div>
    
    <div class="main-container">
        <div class="editor-container" id="editorContainer">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <button class="console-open-btn" id="consoleOpenBtn" title="Open Console">📟</button>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <button class="editor-toggle-btn" id="editorToggleBtn" onclick="toggleEditor()">CODE</button>
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Babylon.js...</div>
        </div>
    </div>
    
    <div class="footer">
        Babylon.js Playground - Powered by WebGL
    </div>
    
    <div class="error-display" id="errorDisplay"></div>

    <!-- Floating Console Window -->
    <div class="console-window" id="consoleWindow">
        <div class="console-title-bar" id="consoleTitleBar">
            <div class="console-title">Console</div>
            <div class="console-controls">
                <button class="console-btn" id="consoleMinimizeBtn" title="Minimize">−</button>
                <button class="console-btn" id="consoleToggleBtn" title="Expand">↕</button>
                <button class="console-btn" id="consoleCloseBtn" title="Close">×</button>
            </div>
        </div>
        <div class="console-content" id="consoleContent"></div>
        <div class="console-resize-handle" id="consoleResizeHandle"></div>
    </div>

    <script>
        let editor;
        let engine;
        let scene;
        let isResizing = false;
        let consoleMessages = [];
        let isEditorOpen = false;

        // Editor toggle functionality - switches between code view (100%) and scene view (100%)
        function toggleEditor() {
            isEditorOpen = !isEditorOpen;
            const editorContainer = document.getElementById('editorContainer');
            const canvasContainer = document.getElementById('canvasContainer');
            const toggleBtn = document.getElementById('editorToggleBtn');

            if (isEditorOpen) {
                // Show code editor (100%), hide scene (0%)
                editorContainer.classList.add('open');
                canvasContainer.classList.add('editor-open');
                toggleBtn.classList.add('editor-open');
                toggleBtn.textContent = 'SCENE';

                // Trigger Monaco layout after transition completes
                setTimeout(() => {
                    if (editor && typeof editor.layout === 'function') {
                        editor.layout();
                    }
                }, 300);
            } else {
                // Show scene (100%), hide code editor (0%)
                editorContainer.classList.remove('open');
                canvasContainer.classList.remove('editor-open');
                toggleBtn.classList.remove('editor-open');
                toggleBtn.textContent = 'CODE';
            }

            // Resize canvas and engine
            if (engine) {
                setTimeout(() => engine.resize(), 350);
            }
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Initialize Monaco Editor with enhanced error handling and fallback
        console.log('Starting Monaco Editor initialization...');
        
        // Set longer timeout for CDN loading
        let monacoTimeout = setTimeout(() => {
            console.error('❌ Monaco Editor CDN loading timeout - creating fallback editor');
            createFallbackEditor();
        }, 10000); // 10 second timeout
        
        require.config({ 
            paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' },
            waitSeconds: 30 // Increase wait time for CDN
        });
        
        require(['vs/editor/editor.main'], function () {
            clearTimeout(monacoTimeout); // Cancel timeout since loading succeeded
            console.log('✅ Monaco modules loaded successfully, creating editor...');
            
            try {
                const editorContainer = document.getElementById('monaco-editor');
                if (!editorContainer) {
                    throw new Error('Monaco editor container not found');
                }
                
                editor = monaco.editor.create(editorContainer, {
                    value: getDefaultCode(),
                    language: 'typescript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('✅ Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible with multiple references
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                // Enhanced readiness check with multiple verification steps
                function verifyAndMarkReady() {
                    console.log('🔍 Verifying Monaco editor readiness...');
                    console.log('- Editor instance:', !!editor);
                    console.log('- Editor model:', !!editor.getModel());
                    console.log('- setValue function:', typeof editor.setValue === 'function');
                    console.log('- getValue function:', typeof editor.getValue === 'function');
                    console.log('- DOM ready:', document.readyState);
                    
                    if (editor && editor.getModel && 
                        typeof editor.setValue === 'function' && 
                        typeof editor.getValue === 'function') {
                        
                        // Final functional test
                        try {
                            const testContent = editor.getValue();
                            editor.layout(); // Trigger layout calculation
                            console.log('✅ Monaco functional test passed - content length:', testContent.length);
                            
                            // Mark as ready
                            window.editorReady = true;
                            console.log('🎯 MONACO EDITOR MARKED AS READY FOR INJECTION');
                            
                            // Initialize Babylon after Monaco is confirmed ready
                            initializeBabylon();
                            
                        } catch (testError) {
                            console.error('❌ Monaco functional test failed:', testError);
                            setTimeout(verifyAndMarkReady, 500); // Retry
                        }
                    } else {
                        console.warn('⚠️ Monaco not fully ready yet, retrying...');
                        setTimeout(verifyAndMarkReady, 500); // Retry
                    }
                }
                
                // Start verification process with initial delay
                setTimeout(verifyAndMarkReady, 1000);
                
            } catch (editorError) {
                console.error('❌ Failed to create Monaco editor:', editorError);
                createFallbackEditor();
            }
        }, function(error) {
            clearTimeout(monacoTimeout);
            console.error('❌ Failed to load Monaco from CDN:', error);
            createFallbackEditor();
        });
        
        // Fallback editor function
        function createFallbackEditor() {
            console.log('🔧 Creating fallback textarea editor...');
            
            const editorContainer = document.getElementById('monaco-editor');
            if (!editorContainer) {
                console.error('❌ Editor container not found');
                return;
            }
            
            // Create a textarea fallback
            editorContainer.innerHTML = '<textarea id="fallback-editor" style="width: 100%; height: 100%; background: #1e1e1e; color: #fff; font-family: \'Monaco\', \'Consolas\', monospace; font-size: 14px; border: none; outline: none; padding: 10px;"></textarea>';
            
            const textarea = document.getElementById('fallback-editor');
            if (textarea) {
                textarea.value = getDefaultCode();
                
                // Create minimal editor interface
                window.editor = {
                    setValue: (code) => { textarea.value = code; },
                    getValue: () => textarea.value,
                    getModel: () => ({ setValue: (code) => textarea.value = code }),
                    layout: () => {},
                    focus: () => textarea.focus(),
                    setPosition: () => {},
                    onDidChangeModelContent: (callback) => {
                        textarea.addEventListener('input', callback);
                        return { dispose: () => {} };
                    }
                };
                
                window.monacoEditor = window.editor;
                window.codeEditor = window.editor;
                
                // Auto-save on changes
                textarea.addEventListener('input', () => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Mark as ready
                window.editorReady = true;
                console.log('✅ Fallback editor ready for injection');
                
                // Initialize Babylon
                initializeBabylon();
            }
        }
        
        // Initialize Babylon.js
        function initializeBabylon() {
            console.log('Initializing Babylon.js...');
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                disableWebGL2Support: false
            });
            
            console.log('Babylon.js engine created');
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Create default scene
            createDefaultScene();
            
            // Render loop
            engine.runRenderLoop(() => {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });
            
            console.log('Babylon.js render loop started');
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Checking components before signaling ready...');
                console.log('Editor available:', typeof editor !== 'undefined' && !!editor);
                console.log('Editor ready flag:', !!window.editorReady);
                console.log('Engine available:', !!engine);
                console.log('BABYLON available:', !!BABYLON);
                
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!engine 
                });
                console.log('Playground fully initialized');
            }, 1500);  // Give even more time for Monaco to be fully ready
        }
        
        function getDefaultCode() {
            return `// Welcome to Babylon.js Playground!
// Create your 3D scene using TypeScript/JavaScript

const createScene = () => {
    // Create scene
    const scene = new BABYLON.Scene(engine);
    
    // Create camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    
    // Attach camera controls - modern API
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    } else if (scene.actionManager) {
        scene.actionManager = new BABYLON.ActionManager(scene);
    }
    
    // Create light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;
    
    // Create sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;
    
    // Create ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    
    console.log("Scene created with camera:", !!camera, "light:", !!light);
    
    return scene;
};

// Execute the scene creation
const scene = createScene();`;
        }
        
        function createDefaultScene() {
            try {
                // Clear existing scene
                if (scene) {
                    scene.dispose();
                }
                
                // Execute user code
                const userCode = editor ? editor.getValue() : getDefaultCode();
                executeUserCode(userCode);
                
                hideError();
            } catch (error) {
                showError('Scene Creation Error: ' + error.message);
                console.error('Scene creation error:', error);
            }
        }
        
        function cleanBabylonJSCode(code) {
            console.log('🧹 Cleaning Babylon.js code - converting Color3 static properties to constructors');
            let cleanedCode = code;

            // Map of Color3 static properties to RGB constructor values
            const colorReplacements = {
                // Common colors - with parentheses (function call style)
                'Color3.Red()': 'new Color3(1, 0, 0)',
                'Color3.Green()': 'new Color3(0, 1, 0)',
                'Color3.Blue()': 'new Color3(0, 0, 1)',
                'Color3.Yellow()': 'new Color3(1, 1, 0)',
                'Color3.Orange()': 'new Color3(1, 0.5, 0)',
                'Color3.Purple()': 'new Color3(0.5, 0, 1)',
                'Color3.Magenta()': 'new Color3(1, 0, 1)',
                'Color3.Cyan()': 'new Color3(0, 1, 1)',
                'Color3.White()': 'new Color3(1, 1, 1)',
                'Color3.Black()': 'new Color3(0, 0, 0)',
                'Color3.Gray()': 'new Color3(0.5, 0.5, 0.5)',
                'Color3.Teal()': 'new Color3(0, 0.5, 0.5)',

                // BABYLON namespace versions - with parentheses
                'BABYLON.Color3.Red()': 'new BABYLON.Color3(1, 0, 0)',
                'BABYLON.Color3.Green()': 'new BABYLON.Color3(0, 1, 0)',
                'BABYLON.Color3.Blue()': 'new BABYLON.Color3(0, 0, 1)',
                'BABYLON.Color3.Yellow()': 'new BABYLON.Color3(1, 1, 0)',
                'BABYLON.Color3.Orange()': 'new BABYLON.Color3(1, 0.5, 0)',
                'BABYLON.Color3.Purple()': 'new BABYLON.Color3(0.5, 0, 1)',
                'BABYLON.Color3.Magenta()': 'new BABYLON.Color3(1, 0, 1)',
                'BABYLON.Color3.Cyan()': 'new BABYLON.Color3(0, 1, 1)',
                'BABYLON.Color3.White()': 'new BABYLON.Color3(1, 1, 1)',
                'BABYLON.Color3.Black()': 'new BABYLON.Color3(0, 0, 0)',
                'BABYLON.Color3.Gray()': 'new BABYLON.Color3(0.5, 0.5, 0.5)',
                'BABYLON.Color3.Teal()': 'new BABYLON.Color3(0, 0.5, 0.5)',

                // Without parentheses (property access style)
                'Color3.Red': 'new Color3(1, 0, 0)',
                'Color3.Green': 'new Color3(0, 1, 0)',
                'Color3.Blue': 'new Color3(0, 0, 1)',
                'Color3.Yellow': 'new Color3(1, 1, 0)',
                'Color3.Orange': 'new Color3(1, 0.5, 0)',
                'Color3.Purple': 'new Color3(0.5, 0, 1)',
                'Color3.Magenta': 'new Color3(1, 0, 1)',
                'Color3.Cyan': 'new Color3(0, 1, 1)',
                'Color3.White': 'new Color3(1, 1, 1)',
                'Color3.Black': 'new Color3(0, 0, 0)',
                'Color3.Gray': 'new Color3(0.5, 0.5, 0.5)',
                'Color3.Teal': 'new Color3(0, 0.5, 0.5)',

                // BABYLON namespace versions - without parentheses
                'BABYLON.Color3.Red': 'new BABYLON.Color3(1, 0, 0)',
                'BABYLON.Color3.Green': 'new BABYLON.Color3(0, 1, 0)',
                'BABYLON.Color3.Blue': 'new BABYLON.Color3(0, 0, 1)',
                'BABYLON.Color3.Yellow': 'new BABYLON.Color3(1, 1, 0)',
                'BABYLON.Color3.Orange': 'new BABYLON.Color3(1, 0.5, 0)',
                'BABYLON.Color3.Purple': 'new BABYLON.Color3(0.5, 0, 1)',
                'BABYLON.Color3.Magenta': 'new BABYLON.Color3(1, 0, 1)',
                'BABYLON.Color3.Cyan': 'new BABYLON.Color3(0, 1, 1)',
                'BABYLON.Color3.White': 'new BABYLON.Color3(1, 1, 1)',
                'BABYLON.Color3.Black': 'new BABYLON.Color3(0, 0, 0)',
                'BABYLON.Color3.Gray': 'new BABYLON.Color3(0.5, 0.5, 0.5)',
                'BABYLON.Color3.Teal': 'new BABYLON.Color3(0, 0.5, 0.5)'
            };

            // First pass: Replace function call style (with parentheses) - more specific
            for (const [oldColor, newColor] of Object.entries(colorReplacements)) {
                if (oldColor.includes('()')) {
                    const regex = new RegExp(oldColor.replace(/\./g, '\\.').replace(/\(/g, '\\(').replace(/\)/g, '\\)'), 'g');
                    const beforeCount = (cleanedCode.match(regex) || []).length;
                    if (beforeCount > 0) {
                        cleanedCode = cleanedCode.replace(regex, newColor);
                        console.log(`  ✅ Replaced ${beforeCount} instances of ${oldColor} → ${newColor}`);
                    }
                }
            }

            // Second pass: Replace property access style (without parentheses)
            // Use word boundaries to avoid replacing Color3.Red when it's part of Color3.Red()
            for (const [oldColor, newColor] of Object.entries(colorReplacements)) {
                if (!oldColor.includes('()')) {
                    // Use word boundary (\b) to match only complete property names
                    const regex = new RegExp(oldColor.replace(/\./g, '\\.') + '\\b', 'g');
                    const beforeCount = (cleanedCode.match(regex) || []).length;
                    if (beforeCount > 0) {
                        cleanedCode = cleanedCode.replace(regex, newColor);
                        console.log(`  ✅ Replaced ${beforeCount} instances of ${oldColor} → ${newColor}`);
                    }
                }
            }

            console.log('🧹 Babylon.js code cleaning complete');
            return cleanedCode;
        }

        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING USER CODE ===');
                console.log('Code to execute (original):', code);

                // Clean Color3 static properties before execution
                code = cleanBabylonJSCode(code);
                console.log('Code to execute (cleaned):', code);

                // Clear previous console messages for new execution
                clearConsole();
                
                // Dispose existing scene if any
                if (scene) {
                    console.log('Disposing existing scene');
                    scene.dispose();
                    scene = null;
                }
                
                // Make sure canvas is available globally
                const canvasElement = document.getElementById('renderCanvas');
                if (!canvasElement) {
                    throw new Error('Canvas element not found');
                }
                
                // Make variables available globally for user code
                window.canvas = canvasElement;
                window.engine = engine;
                window.BABYLON = BABYLON;
                
                console.log('Canvas available:', !!window.canvas);
                console.log('Engine available:', !!window.engine);
                console.log('BABYLON available:', !!window.BABYLON);
                
                // Execute the code in the global context with proper error handling
                try {
                    // Create a safer execution context
                    const executeCode = new Function('canvas', 'engine', 'BABYLON', 
                        `
                        try {
                            ${code}
                            if (typeof scene !== 'undefined') {
                                console.log('Scene variable found:', !!scene);
                                return scene;
                            } else {
                                console.error('No scene variable found in executed code');
                                return null;
                            }
                        } catch (execError) {
                            console.error('Code execution error:', execError);
                            throw execError;
                        }
                        `
                    );
                    
                    // Execute with proper context
                    scene = executeCode(canvasElement, engine, BABYLON);
                    
                } catch (execError) {
                    console.error('Function execution failed:', execError);
                    throw execError;
                }
                
                if (!scene) {
                    throw new Error('Scene creation failed - no scene object returned');
                }
                
                console.log('✅ Scene created successfully:', scene);
                console.log('Scene cameras:', scene.cameras?.length || 0);
                console.log('Scene meshes:', scene.meshes?.length || 0);
                console.log('Scene lights:', scene.lights?.length || 0);
                
                // Force a render update
                if (engine && scene) {
                    console.log('Forcing scene render...');
                    scene.render();
                    engine.resize();
                }
                
                // Hide any error displays
                hideError();
                
                // Clear console and show success
                setTimeout(() => {
                    console.log('🎉 NEW SCENE LOADED SUCCESSFULLY!');
                    addConsoleMessage('log', '🎉 Scene loaded with ' + (scene.meshes?.length || 0) + ' objects');
                    
                    // Ensure the scene is actively rendering
                    if (scene.activeCamera) {
                        console.log('Active camera found, scene should be rendering');
                    } else {
                        console.warn('No active camera found!');
                    }
                }, 100);
                
                // Notify Swift about successful scene creation
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('❌ executeUserCode failed:', errorMsg);
                console.error('Error stack:', error.stack);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Fall back to default scene on error
                console.log('Falling back to default scene...');
                try {
                    scene = createDefaultBabylonScene();
                } catch (fallbackError) {
                    console.error('Even fallback failed:', fallbackError);
                }
            }
        }
        
        // Create a simple fallback scene
        function createDefaultBabylonScene() {
            console.log('Creating fallback default scene');
            const fallbackScene = new BABYLON.Scene(engine);
            
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), fallbackScene);
            camera.setTarget(BABYLON.Vector3.Zero());
            if (camera.attachControls) {
                camera.attachControls(canvas, true);
            }
            
            const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), fallbackScene);
            light.intensity = 0.7;
            
            const sphere = BABYLON.MeshBuilder.CreateSphere("fallback", {diameter: 2}, fallbackScene);
            sphere.position.y = 1;
            
            console.log('Fallback scene created');
            return fallbackScene;
        }
        
        // Playground functions exposed to Swift
        function runCode() {
            console.log('Run code button pressed');
            createDefaultScene();
            notifySwift('codeRun', {});
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function showExamples() {
            notifySwift('showExamples', {});
        }
        
        // Floating Console Window Management
        let consoleState = {
            x: null,
            y: null,
            width: 400,
            height: 300,
            minimized: false,
            hidden: false
        };

        function initFloatingConsole() {
            const consoleWindow = document.getElementById('consoleWindow');
            const titleBar = document.getElementById('consoleTitleBar');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');
            const toggleBtn = document.getElementById('consoleToggleBtn');
            const closeBtn = document.getElementById('consoleCloseBtn');
            const resizeHandle = document.getElementById('consoleResizeHandle');
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');

            // Safety check - return if elements don't exist yet
            if (!consoleWindow || !titleBar || !minimizeBtn || !toggleBtn || !closeBtn || !resizeHandle || !consoleOpenBtn) {
                console.warn('Console elements not ready yet, skipping initialization');
                return;
            }

            // Load saved state from localStorage
            const saved = localStorage.getItem('babylonjs_console_state');
            if (saved) {
                consoleState = { ...consoleState, ...JSON.parse(saved) };
                applyConsoleState();
            }

            // Minimize button
            minimizeBtn.addEventListener('click', () => {
                consoleState.minimized = !consoleState.minimized;
                consoleWindow.classList.toggle('minimized', consoleState.minimized);
                minimizeBtn.textContent = consoleState.minimized ? '+' : '−';
                saveConsoleState();
            });

            // Toggle/Expand button
            toggleBtn.addEventListener('click', () => {
                if (consoleState.minimized) {
                    consoleState.minimized = false;
                    consoleWindow.classList.remove('minimized');
                    minimizeBtn.textContent = '−';
                }
                saveConsoleState();
            });

            // Close button
            closeBtn.addEventListener('click', () => {
                consoleState.hidden = true;
                consoleWindow.classList.add('hidden');
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Dragging
            let isDragging = false;
            let dragStartX, dragStartY, dragStartLeft, dragStartTop;

            titleBar.addEventListener('mousedown', startDrag);
            titleBar.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                if (e.target.closest('.console-btn')) return;
                isDragging = true;

                const rect = consoleWindow.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                dragStartX = clientX;
                dragStartY = clientY;
                dragStartLeft = rect.left;
                dragStartTop = rect.top;

                e.preventDefault();
            }

            function doDrag(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - dragStartX;
                const deltaY = clientY - dragStartY;

                consoleState.x = dragStartLeft + deltaX;
                consoleState.y = dragStartTop + deltaY;

                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';

                e.preventDefault();
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);

            // Resizing
            let isResizing = false;
            let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;

            resizeHandle.addEventListener('mousedown', startResize);
            resizeHandle.addEventListener('touchstart', startResize, { passive: false });

            function startResize(e) {
                isResizing = true;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                resizeStartX = clientX;
                resizeStartY = clientY;
                resizeStartWidth = consoleWindow.offsetWidth;
                resizeStartHeight = consoleWindow.offsetHeight;

                e.preventDefault();
                e.stopPropagation();
            }

            function doResize(e) {
                if (!isResizing) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - resizeStartX;
                const deltaY = clientY - resizeStartY;

                consoleState.width = Math.max(300, Math.min(resizeStartWidth + deltaX, window.innerWidth * 0.9));
                consoleState.height = Math.max(200, Math.min(resizeStartHeight + deltaY, window.innerHeight * 0.8));

                consoleWindow.style.width = consoleState.width + 'px';
                consoleWindow.style.height = consoleState.height + 'px';

                e.preventDefault();
            }

            function stopResize() {
                if (isResizing) {
                    isResizing = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchend', stopResize);

            // Console Open Button (already declared at top of function)
            consoleOpenBtn.addEventListener('click', () => {
                consoleState.hidden = false;
                consoleState.minimized = false;
                consoleWindow.classList.remove('hidden');
                consoleWindow.classList.remove('minimized');
                minimizeBtn.textContent = '−';
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Update button visibility based on console state
            updateConsoleOpenButtonVisibility();
        }

        function updateConsoleOpenButtonVisibility() {
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');
            const consoleWindow = document.getElementById('consoleWindow');

            // Show button only when console is hidden
            if (consoleState.hidden) {
                consoleOpenBtn.classList.remove('hidden');
            } else {
                consoleOpenBtn.classList.add('hidden');
            }
        }

        function applyConsoleState() {
            const consoleWindow = document.getElementById('consoleWindow');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');

            if (consoleState.x !== null && consoleState.y !== null) {
                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';
            }

            consoleWindow.style.width = consoleState.width + 'px';
            consoleWindow.style.height = consoleState.height + 'px';

            consoleWindow.classList.toggle('minimized', consoleState.minimized);
            consoleWindow.classList.toggle('hidden', consoleState.hidden);
            minimizeBtn.textContent = consoleState.minimized ? '+' : '−';

            updateConsoleOpenButtonVisibility();
        }

        function saveConsoleState() {
            localStorage.setItem('babylonjs_console_state', JSON.stringify(consoleState));
        }

        function toggleConsole() {
            consoleState.hidden = !consoleState.hidden;
            document.getElementById('consoleWindow').classList.toggle('hidden', consoleState.hidden);
            saveConsoleState();
            updateConsoleOpenButtonVisibility();
            if (!consoleState.hidden && consoleMessages.length === 0) {
                console.log('Console opened - no messages yet');
            }
        }

        // Initialize console on page load
        window.addEventListener('DOMContentLoaded', initFloatingConsole);
        
        function loadExample(exampleId) {
            if (!exampleId) return;
            
            const examples = {
                'basic-scene': getDefaultCode(),
                'rotating-cube': getRotatingCubeCode(),
                'lighting': getLightingDemoCode(),
                'materials': getMaterialsDemoCode()
            };
            
            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion function for AI assistance with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('🎯 insertCodeAtCursor called with code length:', codeString.length);
            console.log('🔍 Current editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('✅ Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('✅ Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('❌ Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('⚠️ Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        // Enhanced function to completely replace editor content with multi-level retry
        function setFullEditorContent(codeString) {
            console.log('🎯 setFullEditorContent called with code length:', codeString.length);
            console.log('🔍 Editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('📝 Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('✅ Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('⚠️ Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('📝 Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('✅ Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('📝 Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('✅ Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('❌ Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`🎉 Content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('🚀 Auto-running the injected code...');
                                runCode();
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true 
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`❌ Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('❌ All injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All injection strategies failed'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management functions
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50); // Keep last 50 messages
            }
            updateConsoleDisplay();
        }
        
        function updateConsoleDisplay() {
            const consoleContent = document.getElementById('consoleContent');
            if (consoleContent && consoleMessages.length > 0) {
                consoleContent.innerHTML = consoleMessages.map(msg =>
                    `<div class="console-message console-${msg.type}">${escapeHtml(msg.message)}</div>`
                ).join('');
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Example code templates
        function getRotatingCubeCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    
    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    
    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }
    
    // Light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    
    // Create box
    const box = BABYLON.MeshBuilder.CreateBox("box", {size: 2}, scene);
    box.position.y = 1;
    
    // Animation
    scene.registerBeforeRender(() => {
        box.rotation.x += 0.01;
        box.rotation.y += 0.01;
    });
    
    console.log("Rotating cube scene created");
    
    return scene;
};

const scene = createScene();`;
        }
        
        function getLightingDemoCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    
    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControls(canvas, true);
    
    // Lights
    const hemisphericLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    hemisphericLight.intensity = 0.3;
    
    const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -1, -1), scene);
    directionalLight.position = new BABYLON.Vector3(10, 10, 10);
    directionalLight.intensity = 0.7;
    
    // Objects
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position = new BABYLON.Vector3(-2, 1, 0);
    
    const box = BABYLON.MeshBuilder.CreateBox("box", {size: 2}, scene);
    box.position = new BABYLON.Vector3(2, 1, 0);
    
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
    
    return scene;
};

const scene = createScene();`;
        }
        
        function getMaterialsDemoCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    
    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControls(canvas, true);
    
    // Light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    
    // Materials
    const redMaterial = new BABYLON.StandardMaterial("redMaterial", scene);
    redMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0);
    
    const blueMaterial = new BABYLON.StandardMaterial("blueMaterial", scene);
    blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1);
    blueMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    
    const greenMaterial = new BABYLON.StandardMaterial("greenMaterial", scene);
    greenMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
    greenMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);
    
    // Objects with materials
    const sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {diameter: 2}, scene);
    sphere1.position = new BABYLON.Vector3(-3, 1, 0);
    sphere1.material = redMaterial;
    
    const sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {diameter: 2}, scene);
    sphere2.position = new BABYLON.Vector3(0, 1, 0);
    sphere2.material = blueMaterial;
    
    const sphere3 = BABYLON.MeshBuilder.CreateSphere("sphere3", {diameter: 2}, scene);
    sphere3.position = new BABYLON.Vector3(3, 1, 0);
    sphere3.material = greenMaterial;
    
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
    
    return scene;
};

const scene = createScene();`;
        }
        
        // MARK: - Testing and Debugging Functions
        
        /// Test injection system - can be called from browser console
        function testInjection() {
            console.log('🧪 Testing injection system from playground...');
            notifySwift('testInjection', {});
        }
        
        /// Check editor readiness - can be called from browser console  
        function checkEditorReadiness() {
            const monacoReady = window.editor && 
                               typeof window.editor.setValue === 'function' && 
                               typeof window.editor.getValue === 'function' &&
                               typeof window.editor.layout === 'function';
            
            const editorFlagReady = window.editorReady === true;
            const domReady = document.readyState === 'complete';
            const injectionFuncReady = typeof window.setFullEditorContent === 'function';
            
            const result = {
                monaco: monacoReady,
                flag: editorFlagReady, 
                dom: domReady,
                injection: injectionFuncReady,
                ready: monacoReady && editorFlagReady && domReady
            };
            
            console.log('🧪 Editor readiness check:', result);
            return result;
        }
        
        // Make test functions globally available
        window.testInjection = testInjection;
        window.checkEditorReadiness = checkEditorReadiness;
        
        console.log('🧪 Test functions available: testInjection(), checkEditorReadiness()');
    </script>
</body>
</html>