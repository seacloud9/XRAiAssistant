<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Playground</title>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #1177bb;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .editor-container {
            width: 0%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease-in-out;
        }

        .editor-container.open {
            width: 100%;
        }

        .canvas-container {
            width: 100%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.3s ease-in-out;
        }

        .canvas-container.editor-open {
            width: 0%;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
        }
        
        .editor-toggle-btn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: #007acc;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 12px 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            z-index: 20;
            transition: all 0.3s ease-in-out;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .editor-toggle-btn:hover {
            background: #1177bb;
        }

        .editor-toggle-btn:active {
            background: #0e639c;
        }

        /* When editor is open, button moves to right edge */
        .editor-toggle-btn.editor-open {
            left: auto;
            right: 0;
            border-radius: 4px 0 0 4px;
        }
        
        .footer {
            background: #007acc;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        /* Floating Console Window */
        .console-window {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            background: #1e1e1e;
            border: 1px solid #007acc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            z-index: 2000;
            resize: both;
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            max-width: 90vw;
            max-height: 80vh;
        }

        .console-window.minimized {
            height: auto !important;
            min-height: auto;
            resize: none;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        .console-window.hidden {
            display: none;
        }

        .console-title-bar {
            background: #007acc;
            color: white;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .console-title {
            flex: 1;
        }

        .console-controls {
            display: flex;
            gap: 8px;
        }

        .console-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .console-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .console-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #ccc;
            background: #1e1e1e;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }

        .console-window.minimized .console-content {
            display: none;
        }

        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
            white-space: pre-wrap;
            user-select: text;
            -webkit-user-select: text;
        }

        .console-error {
            color: #f14c4c;
        }

        .console-warning {
            color: #ffcc02;
        }

        .console-log {
            color: #ccc;
        }

        .console-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #007acc 50%);
            opacity: 0.5;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        /* Console Open Button (always visible in editor) */
        .console-open-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .console-open-btn:hover {
            background: #1177bb;
            transform: scale(1.1);
        }

        .console-open-btn:active {
            background: #0e639c;
            transform: scale(0.95);
        }

        .console-open-btn.hidden {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        /* Remove media query - same behavior across all devices per requirements */
        /* The editor starts hidden (width: 0%) on all screen sizes */
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">▶ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">🗑 Clear</button>
        <button class="menu-btn" onclick="saveScene()">💾 Save</button>
        <button class="menu-btn" onclick="downloadScene()">⬇ Download</button>
        <button class="menu-btn" onclick="newScene()">📄 New</button>
        <button class="menu-btn" onclick="openDocumentation()">📖 Documentation</button>
        <button class="menu-btn" onclick="toggleConsole()">🖥 Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Select Example...</option>
            <option value="floating-crystal-gems">💎 Floating Crystal Gems</option>
            <option value="physics">⚽ Sphere with Physics</option>
            <option value="path-animation">🛤️ Animated Path Following</option>
            <option value="dynamic-lighting">💡 Dynamic Lighting Scene</option>
            <option value="pbr-materials">✨ PBR Materials Showcase</option>
            <option value="glow-effect">🌟 Glow Effect (Bloom)</option>
            <option value="click-interaction">👆 Click Interaction</option>
            <option value="holographic-torus-array">🌈 Holographic Torus Array</option>
            <option value="particle-fountain">⛲ Particle Fountain</option>
            <option value="fractal-sphere-grid">🔮 Fractal Sphere Grid</option>
            <option value="skybox-fog">🌫️ Skybox with Fog</option>
            <option value="plasma-orb">⚡ Plasma Orb</option>
            <option value="spotlight-showcase">💡 Spotlight Showcase</option>
        </select>
    </div>
    
    <div class="main-container">
        <div class="editor-container" id="editorContainer">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <button class="console-open-btn" id="consoleOpenBtn" title="Open Console">📟</button>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <button class="editor-toggle-btn" id="editorToggleBtn" onclick="toggleEditor()">CODE</button>
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Babylon.js...</div>
        </div>
    </div>
    
    <div class="footer">
        Babylon.js Playground - Powered by WebGL
    </div>
    
    <div class="error-display" id="errorDisplay"></div>

    <!-- Floating Console Window -->
    <div class="console-window" id="consoleWindow">
        <div class="console-title-bar" id="consoleTitleBar">
            <div class="console-title">Console</div>
            <div class="console-controls">
                <button class="console-btn" id="consoleMinimizeBtn" title="Minimize">−</button>
                <button class="console-btn" id="consoleToggleBtn" title="Expand">↕</button>
                <button class="console-btn" id="consoleCloseBtn" title="Close">×</button>
            </div>
        </div>
        <div class="console-content" id="consoleContent"></div>
        <div class="console-resize-handle" id="consoleResizeHandle"></div>
    </div>

    <script>
        let editor;
        let engine;
        let scene;
        let isResizing = false;
        let consoleMessages = [];
        let isEditorOpen = false;

        // Editor toggle functionality - switches between code view (100%) and scene view (100%)
        function toggleEditor() {
            isEditorOpen = !isEditorOpen;
            const editorContainer = document.getElementById('editorContainer');
            const canvasContainer = document.getElementById('canvasContainer');
            const toggleBtn = document.getElementById('editorToggleBtn');

            if (isEditorOpen) {
                // Show code editor (100%), hide scene (0%)
                editorContainer.classList.add('open');
                canvasContainer.classList.add('editor-open');
                toggleBtn.classList.add('editor-open');
                toggleBtn.textContent = 'SCENE';

                // Trigger Monaco layout after transition completes
                setTimeout(() => {
                    if (editor && typeof editor.layout === 'function') {
                        editor.layout();
                    }
                }, 300);
            } else {
                // Show scene (100%), hide code editor (0%)
                editorContainer.classList.remove('open');
                canvasContainer.classList.remove('editor-open');
                toggleBtn.classList.remove('editor-open');
                toggleBtn.textContent = 'CODE';
            }

            // Resize canvas and engine
            if (engine) {
                setTimeout(() => engine.resize(), 350);
            }
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Initialize Monaco Editor with enhanced error handling and fallback
        console.log('Starting Monaco Editor initialization...');
        
        // Set longer timeout for CDN loading
        let monacoTimeout = setTimeout(() => {
            console.error('❌ Monaco Editor CDN loading timeout - creating fallback editor');
            createFallbackEditor();
        }, 10000); // 10 second timeout
        
        require.config({ 
            paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' },
            waitSeconds: 30 // Increase wait time for CDN
        });
        
        require(['vs/editor/editor.main'], function () {
            clearTimeout(monacoTimeout); // Cancel timeout since loading succeeded
            console.log('✅ Monaco modules loaded successfully, creating editor...');
            
            try {
                const editorContainer = document.getElementById('monaco-editor');
                if (!editorContainer) {
                    throw new Error('Monaco editor container not found');
                }
                
                editor = monaco.editor.create(editorContainer, {
                    value: getDefaultCode(),
                    language: 'typescript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('✅ Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible with multiple references
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                // Enhanced readiness check with multiple verification steps
                function verifyAndMarkReady() {
                    console.log('🔍 Verifying Monaco editor readiness...');
                    console.log('- Editor instance:', !!editor);
                    console.log('- Editor model:', !!editor.getModel());
                    console.log('- setValue function:', typeof editor.setValue === 'function');
                    console.log('- getValue function:', typeof editor.getValue === 'function');
                    console.log('- DOM ready:', document.readyState);
                    
                    if (editor && editor.getModel && 
                        typeof editor.setValue === 'function' && 
                        typeof editor.getValue === 'function') {
                        
                        // Final functional test
                        try {
                            const testContent = editor.getValue();
                            editor.layout(); // Trigger layout calculation
                            console.log('✅ Monaco functional test passed - content length:', testContent.length);
                            
                            // Mark as ready
                            window.editorReady = true;
                            console.log('🎯 MONACO EDITOR MARKED AS READY FOR INJECTION');
                            
                            // Initialize Babylon after Monaco is confirmed ready
                            initializeBabylon();
                            
                        } catch (testError) {
                            console.error('❌ Monaco functional test failed:', testError);
                            setTimeout(verifyAndMarkReady, 500); // Retry
                        }
                    } else {
                        console.warn('⚠️ Monaco not fully ready yet, retrying...');
                        setTimeout(verifyAndMarkReady, 500); // Retry
                    }
                }
                
                // Start verification process with initial delay
                setTimeout(verifyAndMarkReady, 1000);
                
            } catch (editorError) {
                console.error('❌ Failed to create Monaco editor:', editorError);
                createFallbackEditor();
            }
        }, function(error) {
            clearTimeout(monacoTimeout);
            console.error('❌ Failed to load Monaco from CDN:', error);
            createFallbackEditor();
        });
        
        // Fallback editor function
        function createFallbackEditor() {
            console.log('🔧 Creating fallback textarea editor...');
            
            const editorContainer = document.getElementById('monaco-editor');
            if (!editorContainer) {
                console.error('❌ Editor container not found');
                return;
            }
            
            // Create a textarea fallback
            editorContainer.innerHTML = '<textarea id="fallback-editor" style="width: 100%; height: 100%; background: #1e1e1e; color: #fff; font-family: \'Monaco\', \'Consolas\', monospace; font-size: 14px; border: none; outline: none; padding: 10px;"></textarea>';
            
            const textarea = document.getElementById('fallback-editor');
            if (textarea) {
                textarea.value = getDefaultCode();
                
                // Create minimal editor interface
                window.editor = {
                    setValue: (code) => { textarea.value = code; },
                    getValue: () => textarea.value,
                    getModel: () => ({ setValue: (code) => textarea.value = code }),
                    layout: () => {},
                    focus: () => textarea.focus(),
                    setPosition: () => {},
                    onDidChangeModelContent: (callback) => {
                        textarea.addEventListener('input', callback);
                        return { dispose: () => {} };
                    }
                };
                
                window.monacoEditor = window.editor;
                window.codeEditor = window.editor;
                
                // Auto-save on changes
                textarea.addEventListener('input', () => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Mark as ready
                window.editorReady = true;
                console.log('✅ Fallback editor ready for injection');
                
                // Initialize Babylon
                initializeBabylon();
            }
        }
        
        // Initialize Babylon.js
        function initializeBabylon() {
            console.log('Initializing Babylon.js...');
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                disableWebGL2Support: false
            });
            
            console.log('Babylon.js engine created');
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Create default scene
            createDefaultScene();
            
            // Render loop
            engine.runRenderLoop(() => {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });
            
            console.log('Babylon.js render loop started');
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Checking components before signaling ready...');
                console.log('Editor available:', typeof editor !== 'undefined' && !!editor);
                console.log('Editor ready flag:', !!window.editorReady);
                console.log('Engine available:', !!engine);
                console.log('BABYLON available:', !!BABYLON);
                
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!engine 
                });
                console.log('Playground fully initialized');
            }, 1500);  // Give even more time for Monaco to be fully ready
        }
        
        function getDefaultCode() {
            return `// Welcome to Babylon.js Playground!
// Create your 3D scene using TypeScript/JavaScript

const createScene = () => {
    // Create scene
    const scene = new BABYLON.Scene(engine);
    
    // Create camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    
    // Attach camera controls - modern API
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    } else if (scene.actionManager) {
        scene.actionManager = new BABYLON.ActionManager(scene);
    }
    
    // Create light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;
    
    // Create sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;
    
    // Create ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    
    console.log("Scene created with camera:", !!camera, "light:", !!light);
    
    return scene;
};

// Execute the scene creation
const scene = createScene();`;
        }
        
        function createDefaultScene() {
            try {
                // Clear existing scene
                if (scene) {
                    scene.dispose();
                }
                
                // Execute user code
                const userCode = editor ? editor.getValue() : getDefaultCode();
                executeUserCode(userCode);
                
                hideError();
            } catch (error) {
                showError('Scene Creation Error: ' + error.message);
                console.error('Scene creation error:', error);
            }
        }
        
        function cleanBabylonJSCode(code) {
            console.log('🧹 Cleaning Babylon.js code - converting Color3 static properties to constructors');
            let cleanedCode = code;

            // Map of Color3 static properties to RGB constructor values
            const colorReplacements = {
                // Common colors - with parentheses (function call style)
                'Color3.Red()': 'new Color3(1, 0, 0)',
                'Color3.Green()': 'new Color3(0, 1, 0)',
                'Color3.Blue()': 'new Color3(0, 0, 1)',
                'Color3.Yellow()': 'new Color3(1, 1, 0)',
                'Color3.Orange()': 'new Color3(1, 0.5, 0)',
                'Color3.Purple()': 'new Color3(0.5, 0, 1)',
                'Color3.Magenta()': 'new Color3(1, 0, 1)',
                'Color3.Cyan()': 'new Color3(0, 1, 1)',
                'Color3.White()': 'new Color3(1, 1, 1)',
                'Color3.Black()': 'new Color3(0, 0, 0)',
                'Color3.Gray()': 'new Color3(0.5, 0.5, 0.5)',
                'Color3.Teal()': 'new Color3(0, 0.5, 0.5)',

                // BABYLON namespace versions - with parentheses
                'BABYLON.Color3.Red()': 'new BABYLON.Color3(1, 0, 0)',
                'BABYLON.Color3.Green()': 'new BABYLON.Color3(0, 1, 0)',
                'BABYLON.Color3.Blue()': 'new BABYLON.Color3(0, 0, 1)',
                'BABYLON.Color3.Yellow()': 'new BABYLON.Color3(1, 1, 0)',
                'BABYLON.Color3.Orange()': 'new BABYLON.Color3(1, 0.5, 0)',
                'BABYLON.Color3.Purple()': 'new BABYLON.Color3(0.5, 0, 1)',
                'BABYLON.Color3.Magenta()': 'new BABYLON.Color3(1, 0, 1)',
                'BABYLON.Color3.Cyan()': 'new BABYLON.Color3(0, 1, 1)',
                'BABYLON.Color3.White()': 'new BABYLON.Color3(1, 1, 1)',
                'BABYLON.Color3.Black()': 'new BABYLON.Color3(0, 0, 0)',
                'BABYLON.Color3.Gray()': 'new BABYLON.Color3(0.5, 0.5, 0.5)',
                'BABYLON.Color3.Teal()': 'new BABYLON.Color3(0, 0.5, 0.5)',

                // Without parentheses (property access style)
                'Color3.Red': 'new Color3(1, 0, 0)',
                'Color3.Green': 'new Color3(0, 1, 0)',
                'Color3.Blue': 'new Color3(0, 0, 1)',
                'Color3.Yellow': 'new Color3(1, 1, 0)',
                'Color3.Orange': 'new Color3(1, 0.5, 0)',
                'Color3.Purple': 'new Color3(0.5, 0, 1)',
                'Color3.Magenta': 'new Color3(1, 0, 1)',
                'Color3.Cyan': 'new Color3(0, 1, 1)',
                'Color3.White': 'new Color3(1, 1, 1)',
                'Color3.Black': 'new Color3(0, 0, 0)',
                'Color3.Gray': 'new Color3(0.5, 0.5, 0.5)',
                'Color3.Teal': 'new Color3(0, 0.5, 0.5)',

                // BABYLON namespace versions - without parentheses
                'BABYLON.Color3.Red': 'new BABYLON.Color3(1, 0, 0)',
                'BABYLON.Color3.Green': 'new BABYLON.Color3(0, 1, 0)',
                'BABYLON.Color3.Blue': 'new BABYLON.Color3(0, 0, 1)',
                'BABYLON.Color3.Yellow': 'new BABYLON.Color3(1, 1, 0)',
                'BABYLON.Color3.Orange': 'new BABYLON.Color3(1, 0.5, 0)',
                'BABYLON.Color3.Purple': 'new BABYLON.Color3(0.5, 0, 1)',
                'BABYLON.Color3.Magenta': 'new BABYLON.Color3(1, 0, 1)',
                'BABYLON.Color3.Cyan': 'new BABYLON.Color3(0, 1, 1)',
                'BABYLON.Color3.White': 'new BABYLON.Color3(1, 1, 1)',
                'BABYLON.Color3.Black': 'new BABYLON.Color3(0, 0, 0)',
                'BABYLON.Color3.Gray': 'new BABYLON.Color3(0.5, 0.5, 0.5)',
                'BABYLON.Color3.Teal': 'new BABYLON.Color3(0, 0.5, 0.5)'
            };

            // First pass: Replace function call style (with parentheses) - more specific
            for (const [oldColor, newColor] of Object.entries(colorReplacements)) {
                if (oldColor.includes('()')) {
                    const regex = new RegExp(oldColor.replace(/\./g, '\\.').replace(/\(/g, '\\(').replace(/\)/g, '\\)'), 'g');
                    const beforeCount = (cleanedCode.match(regex) || []).length;
                    if (beforeCount > 0) {
                        cleanedCode = cleanedCode.replace(regex, newColor);
                        console.log(`  ✅ Replaced ${beforeCount} instances of ${oldColor} → ${newColor}`);
                    }
                }
            }

            // Second pass: Replace property access style (without parentheses)
            // Use word boundaries to avoid replacing Color3.Red when it's part of Color3.Red()
            for (const [oldColor, newColor] of Object.entries(colorReplacements)) {
                if (!oldColor.includes('()')) {
                    // Use word boundary (\b) to match only complete property names
                    const regex = new RegExp(oldColor.replace(/\./g, '\\.') + '\\b', 'g');
                    const beforeCount = (cleanedCode.match(regex) || []).length;
                    if (beforeCount > 0) {
                        cleanedCode = cleanedCode.replace(regex, newColor);
                        console.log(`  ✅ Replaced ${beforeCount} instances of ${oldColor} → ${newColor}`);
                    }
                }
            }

            console.log('🧹 Babylon.js code cleaning complete');
            return cleanedCode;
        }

        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING USER CODE ===');
                console.log('Code to execute (original):', code);

                // Clean Color3 static properties before execution
                code = cleanBabylonJSCode(code);
                console.log('Code to execute (cleaned):', code);

                // Clear previous console messages for new execution
                clearConsole();
                
                // Dispose existing scene if any
                if (scene) {
                    console.log('Disposing existing scene');
                    scene.dispose();
                    scene = null;
                }
                
                // Make sure canvas is available globally
                const canvasElement = document.getElementById('renderCanvas');
                if (!canvasElement) {
                    throw new Error('Canvas element not found');
                }
                
                // Make variables available globally for user code
                window.canvas = canvasElement;
                window.engine = engine;
                window.BABYLON = BABYLON;
                
                console.log('Canvas available:', !!window.canvas);
                console.log('Engine available:', !!window.engine);
                console.log('BABYLON available:', !!window.BABYLON);
                
                // Execute the code in the global context with proper error handling
                try {
                    // Create a safer execution context
                    const executeCode = new Function('canvas', 'engine', 'BABYLON', 
                        `
                        try {
                            ${code}
                            if (typeof scene !== 'undefined') {
                                console.log('Scene variable found:', !!scene);
                                return scene;
                            } else {
                                console.error('No scene variable found in executed code');
                                return null;
                            }
                        } catch (execError) {
                            console.error('Code execution error:', execError);
                            throw execError;
                        }
                        `
                    );
                    
                    // Execute with proper context
                    scene = executeCode(canvasElement, engine, BABYLON);
                    
                } catch (execError) {
                    console.error('Function execution failed:', execError);
                    throw execError;
                }
                
                if (!scene) {
                    throw new Error('Scene creation failed - no scene object returned');
                }
                
                console.log('✅ Scene created successfully:', scene);
                console.log('Scene cameras:', scene.cameras?.length || 0);
                console.log('Scene meshes:', scene.meshes?.length || 0);
                console.log('Scene lights:', scene.lights?.length || 0);
                
                // Force a render update
                if (engine && scene) {
                    console.log('Forcing scene render...');
                    scene.render();
                    engine.resize();
                }
                
                // Hide any error displays
                hideError();
                
                // Clear console and show success
                setTimeout(() => {
                    console.log('🎉 NEW SCENE LOADED SUCCESSFULLY!');
                    addConsoleMessage('log', '🎉 Scene loaded with ' + (scene.meshes?.length || 0) + ' objects');
                    
                    // Ensure the scene is actively rendering
                    if (scene.activeCamera) {
                        console.log('Active camera found, scene should be rendering');
                    } else {
                        console.warn('No active camera found!');
                    }
                }, 100);
                
                // Notify Swift about successful scene creation
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('❌ executeUserCode failed:', errorMsg);
                console.error('Error stack:', error.stack);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Fall back to default scene on error
                console.log('Falling back to default scene...');
                try {
                    scene = createDefaultBabylonScene();
                } catch (fallbackError) {
                    console.error('Even fallback failed:', fallbackError);
                }
            }
        }
        
        // Create a simple fallback scene
        function createDefaultBabylonScene() {
            console.log('Creating fallback default scene');
            const fallbackScene = new BABYLON.Scene(engine);
            
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), fallbackScene);
            camera.setTarget(BABYLON.Vector3.Zero());
            if (camera.attachControls) {
                camera.attachControls(canvas, true);
            }
            
            const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), fallbackScene);
            light.intensity = 0.7;
            
            const sphere = BABYLON.MeshBuilder.CreateSphere("fallback", {diameter: 2}, fallbackScene);
            sphere.position.y = 1;
            
            console.log('Fallback scene created');
            return fallbackScene;
        }
        
        // Playground functions exposed to Swift
        function runCode() {
            console.log('Run code button pressed');
            createDefaultScene();
            notifySwift('codeRun', {});
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function openDocumentation() {
            // Open Babylon.js documentation in Safari
            window.location.href = 'https://doc.babylonjs.com/';
        }
        
        // Floating Console Window Management
        let consoleState = {
            x: null,
            y: null,
            width: 400,
            height: 300,
            minimized: false,
            hidden: false
        };

        function initFloatingConsole() {
            const consoleWindow = document.getElementById('consoleWindow');
            const titleBar = document.getElementById('consoleTitleBar');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');
            const toggleBtn = document.getElementById('consoleToggleBtn');
            const closeBtn = document.getElementById('consoleCloseBtn');
            const resizeHandle = document.getElementById('consoleResizeHandle');
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');

            // Safety check - return if elements don't exist yet
            if (!consoleWindow || !titleBar || !minimizeBtn || !toggleBtn || !closeBtn || !resizeHandle || !consoleOpenBtn) {
                console.warn('Console elements not ready yet, skipping initialization');
                return;
            }

            // Load saved state from localStorage
            const saved = localStorage.getItem('babylonjs_console_state');
            if (saved) {
                consoleState = { ...consoleState, ...JSON.parse(saved) };
                applyConsoleState();
            }

            // Minimize button
            minimizeBtn.addEventListener('click', () => {
                consoleState.minimized = !consoleState.minimized;
                consoleWindow.classList.toggle('minimized', consoleState.minimized);
                minimizeBtn.textContent = consoleState.minimized ? '+' : '−';
                saveConsoleState();
            });

            // Toggle/Expand button
            toggleBtn.addEventListener('click', () => {
                if (consoleState.minimized) {
                    consoleState.minimized = false;
                    consoleWindow.classList.remove('minimized');
                    minimizeBtn.textContent = '−';
                }
                saveConsoleState();
            });

            // Close button
            closeBtn.addEventListener('click', () => {
                consoleState.hidden = true;
                consoleWindow.classList.add('hidden');
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Dragging
            let isDragging = false;
            let dragStartX, dragStartY, dragStartLeft, dragStartTop;

            titleBar.addEventListener('mousedown', startDrag);
            titleBar.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                if (e.target.closest('.console-btn')) return;
                isDragging = true;

                const rect = consoleWindow.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                dragStartX = clientX;
                dragStartY = clientY;
                dragStartLeft = rect.left;
                dragStartTop = rect.top;

                e.preventDefault();
            }

            function doDrag(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - dragStartX;
                const deltaY = clientY - dragStartY;

                consoleState.x = dragStartLeft + deltaX;
                consoleState.y = dragStartTop + deltaY;

                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';

                e.preventDefault();
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);

            // Resizing
            let isResizing = false;
            let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;

            resizeHandle.addEventListener('mousedown', startResize);
            resizeHandle.addEventListener('touchstart', startResize, { passive: false });

            function startResize(e) {
                isResizing = true;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                resizeStartX = clientX;
                resizeStartY = clientY;
                resizeStartWidth = consoleWindow.offsetWidth;
                resizeStartHeight = consoleWindow.offsetHeight;

                e.preventDefault();
                e.stopPropagation();
            }

            function doResize(e) {
                if (!isResizing) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - resizeStartX;
                const deltaY = clientY - resizeStartY;

                consoleState.width = Math.max(300, Math.min(resizeStartWidth + deltaX, window.innerWidth * 0.9));
                consoleState.height = Math.max(200, Math.min(resizeStartHeight + deltaY, window.innerHeight * 0.8));

                consoleWindow.style.width = consoleState.width + 'px';
                consoleWindow.style.height = consoleState.height + 'px';

                e.preventDefault();
            }

            function stopResize() {
                if (isResizing) {
                    isResizing = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchend', stopResize);

            // Console Open Button (already declared at top of function)
            consoleOpenBtn.addEventListener('click', () => {
                consoleState.hidden = false;
                consoleState.minimized = false;
                consoleWindow.classList.remove('hidden');
                consoleWindow.classList.remove('minimized');
                minimizeBtn.textContent = '−';
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Update button visibility based on console state
            updateConsoleOpenButtonVisibility();
        }

        function updateConsoleOpenButtonVisibility() {
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');
            const consoleWindow = document.getElementById('consoleWindow');

            // Show button only when console is hidden
            if (consoleState.hidden) {
                consoleOpenBtn.classList.remove('hidden');
            } else {
                consoleOpenBtn.classList.add('hidden');
            }
        }

        function applyConsoleState() {
            const consoleWindow = document.getElementById('consoleWindow');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');

            if (consoleState.x !== null && consoleState.y !== null) {
                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';
            }

            consoleWindow.style.width = consoleState.width + 'px';
            consoleWindow.style.height = consoleState.height + 'px';

            consoleWindow.classList.toggle('minimized', consoleState.minimized);
            consoleWindow.classList.toggle('hidden', consoleState.hidden);
            minimizeBtn.textContent = consoleState.minimized ? '+' : '−';

            updateConsoleOpenButtonVisibility();
        }

        function saveConsoleState() {
            localStorage.setItem('babylonjs_console_state', JSON.stringify(consoleState));
        }

        function toggleConsole() {
            consoleState.hidden = !consoleState.hidden;
            document.getElementById('consoleWindow').classList.toggle('hidden', consoleState.hidden);
            saveConsoleState();
            updateConsoleOpenButtonVisibility();
            if (!consoleState.hidden && consoleMessages.length === 0) {
                console.log('Console opened - no messages yet');
            }
        }

        // Initialize console on page load
        window.addEventListener('DOMContentLoaded', initFloatingConsole);
        
        function loadExample(exampleId) {
            if (!exampleId) return;

            const examples = {
                'floating-crystal-gems': getFloatingCrystalGemsCode(),
                'physics': getPhysicsCode(),
                'path-animation': getPathAnimationCode(),
                'dynamic-lighting': getDynamicLightingCode(),
                'pbr-materials': getPBRMaterialsCode(),
                'glow-effect': getGlowEffectCode(),
                'click-interaction': getClickInteractionCode(),
                'holographic-torus-array': getHolographicTorusArrayCode(),
                'particle-fountain': getParticleFountainCode(),
                'fractal-sphere-grid': getFractalSphereGridCode(),
                'skybox-fog': getSkyboxFogCode(),
                'plasma-orb': getPlasmaOrbCode(),
                'spotlight-showcase': getSpotlightShowcaseCode()
            };

            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion function for AI assistance with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('🎯 insertCodeAtCursor called with code length:', codeString.length);
            console.log('🔍 Current editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('✅ Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('✅ Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('❌ Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('⚠️ Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        // Enhanced function to completely replace editor content with multi-level retry
        function setFullEditorContent(codeString) {
            console.log('🎯 setFullEditorContent called with code length:', codeString.length);
            console.log('🔍 Editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('📝 Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('✅ Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('⚠️ Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('📝 Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('✅ Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('📝 Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('✅ Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('❌ Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`🎉 Content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('🚀 Auto-running the injected code...');
                                runCode();
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true 
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`❌ Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('❌ All injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All injection strategies failed'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management functions
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50); // Keep last 50 messages
            }
            updateConsoleDisplay();
        }
        
        function updateConsoleDisplay() {
            const consoleContent = document.getElementById('consoleContent');
            if (consoleContent && consoleMessages.length > 0) {
                consoleContent.innerHTML = consoleMessages.map(msg =>
                    `<div class="console-message console-${msg.type}">${escapeHtml(msg.message)}</div>`
                ).join('');
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Example code templates
        // Example Code Functions - Updated from Library3D examples
        function getFloatingCrystalGemsCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 12, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.8;

    // Add glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 0.5;

    // Create three floating crystals
    const colors = [
        new BABYLON.Color3(1, 0.2, 0.6),  // Pink
        new BABYLON.Color3(0.2, 0.6, 1),  // Blue
        new BABYLON.Color3(1, 0.8, 0.2)   // Gold
    ];

    for (let i = 0; i < 3; i++) {
        const crystal = BABYLON.MeshBuilder.CreatePolyhedron("crystal" + i, {type: 1, size: 1.2}, scene);
        crystal.position.x = (i - 1) * 3;
        crystal.position.y = 1;

        const material = new BABYLON.PBRMaterial("mat" + i, scene);
        material.albedoColor = colors[i];
        material.metallic = 0.9;
        material.roughness = 0.1;
        material.emissiveColor = colors[i];
        material.emissiveIntensity = 0.3;
        crystal.material = material;

        // Floating animation
        const startY = crystal.position.y;
        scene.registerBeforeRender(() => {
            crystal.rotation.y += 0.005 + i * 0.003;
            crystal.position.y = startY + Math.sin(Date.now() * 0.001 + i) * 0.3;
        });
    }

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 15, height: 15}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
    groundMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ground.material = groundMat;

    return scene;
};
const scene = createScene();`;
        }
        
        function getLightingDemoCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Lights - demonstrating different light types
    const hemisphericLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    hemisphericLight.intensity = 0.3;

    const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -1, -1), scene);
    directionalLight.position = new BABYLON.Vector3(10, 10, 10);
    directionalLight.intensity = 0.7;

    // Objects
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position = new BABYLON.Vector3(-2, 1, 0);

    const box = BABYLON.MeshBuilder.CreateBox("box", {size: 2}, scene);
    box.position = new BABYLON.Vector3(2, 1, 0);

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);

    console.log("Lighting demo scene created successfully");

    return scene;
};

const scene = createScene();`;
        }
        
        function getMaterialsDemoCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Materials
    const redMaterial = new BABYLON.StandardMaterial("redMaterial", scene);
    redMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0);

    const blueMaterial = new BABYLON.StandardMaterial("blueMaterial", scene);
    blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1);
    blueMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

    const greenMaterial = new BABYLON.StandardMaterial("greenMaterial", scene);
    greenMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
    greenMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);

    // Objects with materials
    const sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {diameter: 2}, scene);
    sphere1.position = new BABYLON.Vector3(-3, 1, 0);
    sphere1.material = redMaterial;

    const sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {diameter: 2}, scene);
    sphere2.position = new BABYLON.Vector3(0, 1, 0);
    sphere2.material = blueMaterial;

    const sphere3 = BABYLON.MeshBuilder.CreateSphere("sphere3", {diameter: 2}, scene);
    sphere3.position = new BABYLON.Vector3(3, 1, 0);
    sphere3.material = greenMaterial;

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);

    return scene;
};

const scene = createScene();`;
        }

        function getGlowLayerCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

    // Camera
    const camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 3, 15, BABYLON.Vector3.Zero(), scene);

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    camera.lowerRadiusLimit = 5;
    camera.upperRadiusLimit = 30;

    // Lighting
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.5;

    // Create glow layer for bloom effect
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.0;

    // Create emissive materials for glowing objects
    const colors = [
        new BABYLON.Color3(1, 0.2, 0.2),    // Red
        new BABYLON.Color3(0.2, 1, 0.2),    // Green
        new BABYLON.Color3(0.2, 0.2, 1),    // Blue
        new BABYLON.Color3(1, 1, 0.2),      // Yellow
        new BABYLON.Color3(1, 0.2, 1)       // Magenta
    ];

    // Create glowing spheres in a circle
    for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const x = Math.cos(angle) * 4;
        const z = Math.sin(angle) * 4;

        const sphere = BABYLON.MeshBuilder.CreateSphere(\`sphere\${i}\`, {diameter: 1.5}, scene);
        sphere.position = new BABYLON.Vector3(x, 0, z);

        const material = new BABYLON.StandardMaterial(\`mat\${i}\`, scene);
        material.diffuseColor = colors[i];
        material.emissiveColor = colors[i];
        material.specularColor = new BABYLON.Color3(0, 0, 0);
        sphere.material = material;

        // Animate spheres
        sphere.metadata = {
            initialY: 0,
            speed: 0.5 + Math.random() * 0.5,
            offset: i * Math.PI * 0.4
        };
    }

    // Create central glowing torus
    const torus = BABYLON.MeshBuilder.CreateTorus("torus", {
        diameter: 3,
        thickness: 0.5,
        tessellation: 32
    }, scene);
    torus.position.y = 0;

    const torusMat = new BABYLON.StandardMaterial("torusMat", scene);
    torusMat.diffuseColor = new BABYLON.Color3(0.3, 0.6, 1.0);
    torusMat.emissiveColor = new BABYLON.Color3(0.3, 0.6, 1.0);
    torusMat.specularColor = new BABYLON.Color3(0, 0, 0);
    torus.material = torusMat;

    // Ground plane
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 20}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
    groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
    ground.material = groundMat;

    // Animation
    scene.registerBeforeRender(() => {
        const time = performance.now() * 0.001;

        // Animate spheres
        scene.meshes.forEach(mesh => {
            if (mesh.name.startsWith('sphere')) {
                const meta = mesh.metadata;
                mesh.position.y = meta.initialY + Math.sin(time * meta.speed + meta.offset) * 1.5;
            }
        });

        // Rotate torus
        torus.rotation.x += 0.005;
        torus.rotation.y += 0.01;
    });

    console.log("✨ Glow layer postprocessing scene created!");

    return scene;
};

const scene = createScene();`;
        }

        function getBlurPostProcessCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);

    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Lighting
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const directionalLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
    directionalLight.intensity = 0.5;

    // Create colorful objects
    const colors = [
        new BABYLON.Color3(1, 0.3, 0.3),
        new BABYLON.Color3(0.3, 1, 0.3),
        new BABYLON.Color3(0.3, 0.3, 1)
    ];

    for (let i = 0; i < 3; i++) {
        const box = BABYLON.MeshBuilder.CreateBox(\`box\${i}\`, {size: 1.5}, scene);
        box.position = new BABYLON.Vector3((i - 1) * 3, 1, 0);

        const material = new BABYLON.StandardMaterial(\`mat\${i}\`, scene);
        material.diffuseColor = colors[i];
        material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        box.material = material;

        // Animate rotation
        box.metadata = {speed: 0.01 + i * 0.005};
    }

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 15, height: 15}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ground.material = groundMat;

    // Apply horizontal blur post-process
    const horizontalBlur = new BABYLON.BlurPostProcess(
        "HorizontalBlur",
        new BABYLON.Vector2(1.0, 0),  // Horizontal direction
        10,                            // Kernel size (blur intensity)
        1.0,                           // Sampling ratio
        camera                         // Attach to camera
    );

    // Apply vertical blur post-process
    const verticalBlur = new BABYLON.BlurPostProcess(
        "VerticalBlur",
        new BABYLON.Vector2(0, 1.0),  // Vertical direction
        10,                            // Kernel size
        1.0,                           // Sampling ratio
        camera                         // Attach to camera
    );

    // Animation
    scene.registerBeforeRender(() => {
        scene.meshes.forEach(mesh => {
            if (mesh.name.startsWith('box')) {
                mesh.rotation.x += mesh.metadata.speed;
                mesh.rotation.y += mesh.metadata.speed * 1.5;
            }
        });
    });

    console.log("🌫️ Blur postprocessing scene created!");
    console.log("Blur effects applied to camera - entire scene has depth of field effect");

    return scene;
};

const scene = createScene();`;
        }

        function getBlackAndWhiteCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 0.9);

    // Camera
    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 12, BABYLON.Vector3.Zero(), scene);
    camera.attachControls(canvas, true);

    // Lighting
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const directionalLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
    directionalLight.intensity = 0.5;

    // Create colorful scene (will be converted to B&W)
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;

    const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
    sphereMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2);
    sphereMat.specularColor = new BABYLON.Color3(1, 1, 1);
    sphere.material = sphereMat;

    const torus = BABYLON.MeshBuilder.CreateTorus("torus", {diameter: 3, thickness: 0.5}, scene);
    torus.position.y = 1;

    const torusMat = new BABYLON.StandardMaterial("torusMat", scene);
    torusMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 1);
    torusMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    torus.material = torusMat;

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.3);
    ground.material = groundMat;

    // Apply black and white post-process
    const bwPostProcess = new BABYLON.BlackAndWhitePostProcess("bandw", 1.0, camera);

    // Animation
    scene.registerBeforeRender(() => {
        sphere.rotation.y += 0.01;
        torus.rotation.x += 0.005;
        torus.rotation.z += 0.01;
    });

    console.log("⚫⚪ Black and White postprocessing scene created!");
    console.log("All colors converted to grayscale using BlackAndWhitePostProcess");

    return scene;
};

const scene = createScene();`;
        }

        // New Example Code Functions from Library3D
        function getPhysicsCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Enable physics
    const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin());

    // Create sphere with physics
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 5;
    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, {mass: 1, restitution: 0.9}, scene);

    const material = new BABYLON.StandardMaterial("sphereMat", scene);
    material.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
    sphere.material = material;

    // Ground with physics
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0, restitution: 0.9}, scene);

    return scene;
};
const scene = createScene();`;
        }

        function getPathAnimationCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Create a path
    const path = [];
    for (let i = 0; i < 60; i++) {
        path.push(new BABYLON.Vector3(5 * Math.cos(i * 0.1), 0, 5 * Math.sin(i * 0.1)));
    }

    // Create tube along path
    const tube = BABYLON.MeshBuilder.CreateTube("tube", {path: path, radius: 0.1}, scene);

    // Create moving sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1}, scene);
    const material = new BABYLON.StandardMaterial("mat", scene);
    material.diffuseColor = new BABYLON.Color3(1, 0, 0);
    sphere.material = material;

    // Animation
    let alpha = 0;
    scene.registerBeforeRender(() => {
        alpha += 0.02;
        const index = Math.floor(alpha) % path.length;
        sphere.position = path[index];
    });

    return scene;
};
const scene = createScene();`;
        }

        function getDynamicLightingCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.2);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Create multiple point lights
    const light1 = new BABYLON.PointLight("light1", new BABYLON.Vector3(3, 3, 0), scene);
    light1.diffuse = new BABYLON.Color3(1, 0, 0);
    light1.intensity = 0.5;

    const light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(-3, 3, 0), scene);
    light2.diffuse = new BABYLON.Color3(0, 1, 0);
    light2.intensity = 0.5;

    const light3 = new BABYLON.PointLight("light3", new BABYLON.Vector3(0, 3, 3), scene);
    light3.diffuse = new BABYLON.Color3(0, 0, 1);
    light3.intensity = 0.5;

    // Center object
    const box = BABYLON.MeshBuilder.CreateBox("box", {size: 2}, scene);
    const material = new BABYLON.StandardMaterial("mat", scene);
    material.specularColor = new BABYLON.Color3(1, 1, 1);
    box.material = material;

    // Animate lights
    let time = 0;
    scene.registerBeforeRender(() => {
        time += 0.01;
        light1.position.x = 3 * Math.cos(time);
        light1.position.z = 3 * Math.sin(time);
        light2.position.x = 3 * Math.cos(time + 2.09);
        light2.position.z = 3 * Math.sin(time + 2.09);
        light3.position.x = 3 * Math.cos(time + 4.18);
        light3.position.z = 3 * Math.sin(time + 4.18);
    });

    return scene;
};
const scene = createScene();`;
        }

        function getPBRMaterialsCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 1.0;

    // Create spheres with different materials
    for (let i = 0; i < 5; i++) {
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere" + i, {diameter: 2}, scene);
        sphere.position.x = (i - 2) * 3;

        const material = new BABYLON.PBRMaterial("pbr" + i, scene);
        material.albedoColor = new BABYLON.Color3(1, 0.5, 0);
        material.metallic = i / 4; // Varying metallic
        material.roughness = 0.3;
        sphere.material = material;
    }

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 10}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ground.material = groundMat;

    return scene;
};
const scene = createScene();`;
        }

        function getGlowEffectCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);

    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.3;

    // Create glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.0;

    // Create glowing sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;

    const material = new BABYLON.StandardMaterial("mat", scene);
    material.emissiveColor = new BABYLON.Color3(0, 1, 1);
    material.diffuseColor = new BABYLON.Color3(0, 0.3, 0.3);
    sphere.material = material;

    // Animated rotation
    scene.registerBeforeRender(() => {
        sphere.rotation.y += 0.01;
    });

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);

    return scene;
};
const scene = createScene();`;
        }

        function getClickInteractionCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Create boxes
    const colors = [
        new BABYLON.Color3(1, 0, 0),
        new BABYLON.Color3(0, 1, 0),
        new BABYLON.Color3(0, 0, 1)
    ];

    for (let i = 0; i < 3; i++) {
        const box = BABYLON.MeshBuilder.CreateBox("box" + i, {size: 1.5}, scene);
        box.position.x = (i - 1) * 3;
        box.position.y = 1;

        const material = new BABYLON.StandardMaterial("mat" + i, scene);
        material.diffuseColor = colors[i];
        box.material = material;

        // Add click interaction
        box.actionManager = new BABYLON.ActionManager(scene);
        box.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function() {
                    box.scaling = box.scaling.x === 1 ? new BABYLON.Vector3(1.5, 1.5, 1.5) : new BABYLON.Vector3(1, 1, 1);
                }
            )
        );
    }

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);

    return scene;
};
const scene = createScene();`;
        }

        function getHolographicTorusArrayCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0.02, 0.08);

    const camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 3, 20, new BABYLON.Vector3(0, 0, 0), scene);
    camera.lowerRadiusLimit = 10;
    camera.upperRadiusLimit = 40;
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.4;

    // Create intense glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.5;

    // Create array of torus meshes
    const count = 8;
    const toruses = [];

    for (let i = 0; i < count; i++) {
        const torus = BABYLON.MeshBuilder.CreateTorus("torus" + i, {
            diameter: 3,
            thickness: 0.5,
            tessellation: 64
        }, scene);

        torus.position.z = (i - count / 2) * 2;

        // Create rainbow gradient material
        const hue = (i / count) * 360;
        const r = Math.abs(Math.sin((hue) * Math.PI / 180));
        const g = Math.abs(Math.sin((hue + 120) * Math.PI / 180));
        const b = Math.abs(Math.sin((hue + 240) * Math.PI / 180));

        const material = new BABYLON.PBRMaterial("mat" + i, scene);
        material.albedoColor = new BABYLON.Color3(r, g, b);
        material.metallic = 0.95;
        material.roughness = 0.05;
        material.emissiveColor = new BABYLON.Color3(r * 0.8, g * 0.8, b * 0.8);
        material.emissiveIntensity = 0.8;
        torus.material = material;

        toruses.push(torus);
    }

    // Wave animation
    let time = 0;
    scene.registerBeforeRender(() => {
        time += 0.016;

        // Auto-rotate camera
        camera.alpha += 0.002;

        toruses.forEach((torus, i) => {
            const offset = (i / count) * Math.PI * 2;

            // Wave motion
            torus.position.y = Math.sin(time + offset) * 2.5;

            // Rotation
            torus.rotation.x = time * 0.3;
            torus.rotation.z = time * 0.2;

            // Pulsing scale
            const scale = 1 + Math.sin(time + offset) * 0.15;
            torus.scaling = new BABYLON.Vector3(scale, scale, scale);
        });
    });

    return scene;
};
const scene = createScene();`;
        }

        function getParticleFountainCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.15);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.6;

    // Create particle system
    const particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
    particleSystem.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);

    // Fountain emitter
    particleSystem.emitter = new BABYLON.Vector3(0, 0, 0);
    particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5);
    particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 0.5);

    // Colors
    particleSystem.color1 = new BABYLON.Color4(1, 0.2, 0.6, 1.0);
    particleSystem.color2 = new BABYLON.Color4(0.2, 0.6, 1, 1.0);
    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);

    // Size
    particleSystem.minSize = 0.1;
    particleSystem.maxSize = 0.3;

    // Life time
    particleSystem.minLifeTime = 1.0;
    particleSystem.maxLifeTime = 2.0;

    // Emission rate
    particleSystem.emitRate = 300;

    // Blend mode
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

    // Gravity
    particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

    // Direction
    particleSystem.direction1 = new BABYLON.Vector3(-1, 8, -1);
    particleSystem.direction2 = new BABYLON.Vector3(1, 10, 1);

    // Speed
    particleSystem.minEmitPower = 1;
    particleSystem.maxEmitPower = 3;
    particleSystem.updateSpeed = 0.01;

    particleSystem.start();

    // Base platform
    const base = BABYLON.MeshBuilder.CreateCylinder("base", {diameter: 3, height: 0.5}, scene);
    base.position.y = -0.25;
    const baseMat = new BABYLON.StandardMaterial("baseMat", scene);
    baseMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
    base.material = baseMat;

    return scene;
};
const scene = createScene();`;
        }

        function getFractalSphereGridCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

    const camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 4, 25, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 0.8;

    // Create grid of spheres
    const spheres = [];
    const gridSize = 5;

    for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
            const sphere = BABYLON.MeshBuilder.CreateSphere("sphere" + x + "_" + z, {diameter: 1}, scene);
            sphere.position.x = (x - gridSize / 2) * 2.5;
            sphere.position.z = (z - gridSize / 2) * 2.5;

            // Distance from center for fractal pattern
            const distFromCenter = Math.sqrt(Math.pow(x - gridSize / 2, 2) + Math.pow(z - gridSize / 2, 2));
            const normalizedDist = distFromCenter / (gridSize / 2);

            const material = new BABYLON.PBRMaterial("mat" + x + "_" + z, scene);
            const hue = (x + z) / (gridSize * 2);
            material.albedoColor = new BABYLON.Color3(
                Math.abs(Math.sin(hue * Math.PI * 2)),
                Math.abs(Math.sin((hue + 0.33) * Math.PI * 2)),
                Math.abs(Math.sin((hue + 0.66) * Math.PI * 2))
            );
            material.metallic = 0.9;
            material.roughness = 0.1;
            material.emissiveColor = material.albedoColor;
            material.emissiveIntensity = 0.4;
            sphere.material = material;

            spheres.push({mesh: sphere, dist: normalizedDist, x: x, z: z});
        }
    }

    // Animation
    scene.registerBeforeRender(() => {
        const time = Date.now() * 0.001;

        spheres.forEach(data => {
            const wave = Math.sin(time + data.dist * 3);
            data.mesh.position.y = wave * 1.5;
            data.mesh.rotation.y = time + data.dist;
            const scale = 0.5 + wave * 0.3;
            data.mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
        });
    });

    return scene;
};
const scene = createScene();`;
        }

        function getSkyboxFogCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 20, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Skybox
    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000}, scene);
    const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.15);
    skybox.material = skyboxMaterial;

    // Fog
    scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
    scene.fogDensity = 0.02;
    scene.fogColor = new BABYLON.Color3(0.1, 0.05, 0.15);

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.5;

    // Create floating monoliths
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = 10;

        const monolith = BABYLON.MeshBuilder.CreateBox("monolith" + i, {
            width: 1.5,
            height: 5,
            depth: 1.5
        }, scene);

        monolith.position.x = Math.cos(angle) * radius;
        monolith.position.z = Math.sin(angle) * radius;
        monolith.position.y = 2.5;
        monolith.rotation.y = -angle;

        const material = new BABYLON.PBRMaterial("monolithMat" + i, scene);
        material.albedoColor = new BABYLON.Color3(0.3, 0.2, 0.5);
        material.metallic = 0.8;
        material.roughness = 0.2;
        material.emissiveColor = new BABYLON.Color3(0.5, 0.2, 0.8);
        material.emissiveIntensity = 0.3;
        monolith.material = material;
    }

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 50, height: 50}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.05, 0.15);
    groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    ground.material = groundMat;

    return scene;
};
const scene = createScene();`;
        }

        function getPlasmaOrbCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 8, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.3;

    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.8;

    // Main orb
    const orb = BABYLON.MeshBuilder.CreateSphere("orb", {diameter: 3, segments: 64}, scene);
    const orbMat = new BABYLON.PBRMaterial("orbMat", scene);
    orbMat.albedoColor = new BABYLON.Color3(0.5, 0.1, 1);
    orbMat.metallic = 0.95;
    orbMat.roughness = 0.05;
    orbMat.emissiveColor = new BABYLON.Color3(0.8, 0.2, 1);
    orbMat.emissiveIntensity = 1.5;
    orb.material = orbMat;

    // Electric rings
    const rings = [];
    for (let i = 0; i < 3; i++) {
        const ring = BABYLON.MeshBuilder.CreateTorus("ring" + i, {
            diameter: 4 + i * 0.5,
            thickness: 0.05,
            tessellation: 64
        }, scene);

        const ringMat = new BABYLON.StandardMaterial("ringMat" + i, scene);
        ringMat.emissiveColor = new BABYLON.Color3(0, 1, 1);
        ring.material = ringMat;

        rings.push(ring);
    }

    // Point lights
    const light1 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 0, 0), scene);
    light1.diffuse = new BABYLON.Color3(0.8, 0.2, 1);
    light1.intensity = 2;

    // Animation
    scene.registerBeforeRender(() => {
        const time = Date.now() * 0.001;

        // Pulsating orb
        const scale = 1 + Math.sin(time * 2) * 0.1;
        orb.scaling = new BABYLON.Vector3(scale, scale, scale);

        // Rotating rings at different speeds
        rings.forEach((ring, i) => {
            ring.rotation.x = time * (0.5 + i * 0.2);
            ring.rotation.y = time * (0.3 + i * 0.15);
        });

        // Pulsating glow
        gl.intensity = 1.5 + Math.sin(time * 3) * 0.5;

        // Color shift
        const hue = (time * 0.1) % 1;
        orbMat.emissiveColor = new BABYLON.Color3(
            0.5 + Math.sin(hue * Math.PI * 2) * 0.5,
            0.2,
            0.8 + Math.cos(hue * Math.PI * 2) * 0.2
        );
    });

    return scene;
};
const scene = createScene();`;
        }

        function getSpotlightShowcaseCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.2;

    // Create three spotlights
    const colors = [
        new BABYLON.Color3(1, 0.2, 0.2),
        new BABYLON.Color3(0.2, 1, 0.2),
        new BABYLON.Color3(0.2, 0.2, 1)
    ];

    const spotlights = [];
    for (let i = 0; i < 3; i++) {
        const spotlight = new BABYLON.SpotLight(
            "spot" + i,
            new BABYLON.Vector3((i - 1) * 4, 8, 0),
            new BABYLON.Vector3(0, -1, 0),
            Math.PI / 3,
            2,
            scene
        );
        spotlight.diffuse = colors[i];
        spotlight.intensity = 3;

        // Shadow generator
        const shadowGenerator = new BABYLON.ShadowGenerator(1024, spotlight);
        shadowGenerator.useBlurExponentialShadowMap = true;

        spotlights.push({light: spotlight, shadow: shadowGenerator});

        // Create object under each spotlight
        const box = BABYLON.MeshBuilder.CreateBox("box" + i, {size: 2}, scene);
        box.position.x = (i - 1) * 4;
        box.position.y = 1;

        const material = new BABYLON.StandardMaterial("mat" + i, scene);
        material.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        material.specularColor = colors[i];
        box.material = material;

        shadowGenerator.addShadowCaster(box);
    }

    // Ground with shadow receiving
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 10}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25);
    ground.material = groundMat;
    ground.receiveShadows = true;

    return scene;
};
const scene = createScene();`;
        }

        // MARK: - Testing and Debugging Functions
        
        /// Test injection system - can be called from browser console
        function testInjection() {
            console.log('🧪 Testing injection system from playground...');
            notifySwift('testInjection', {});
        }
        
        /// Check editor readiness - can be called from browser console  
        function checkEditorReadiness() {
            const monacoReady = window.editor && 
                               typeof window.editor.setValue === 'function' && 
                               typeof window.editor.getValue === 'function' &&
                               typeof window.editor.layout === 'function';
            
            const editorFlagReady = window.editorReady === true;
            const domReady = document.readyState === 'complete';
            const injectionFuncReady = typeof window.setFullEditorContent === 'function';
            
            const result = {
                monaco: monacoReady,
                flag: editorFlagReady, 
                dom: domReady,
                injection: injectionFuncReady,
                ready: monacoReady && editorFlagReady && domReady
            };
            
            console.log('🧪 Editor readiness check:', result);
            return result;
        }
        
        // Make test functions globally available
        window.testInjection = testInjection;
        window.checkEditorReadiness = checkEditorReadiness;
        
        console.log('🧪 Test functions available: testInjection(), checkEditorReadiness()');
    </script>
</body>
</html>