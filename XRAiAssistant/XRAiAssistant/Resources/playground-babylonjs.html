<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Playground</title>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #1177bb;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .editor-container {
            width: 0%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease-in-out;
        }

        .editor-container.open {
            width: 100%;
        }

        .canvas-container {
            width: 100%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.3s ease-in-out;
        }

        .canvas-container.editor-open {
            width: 0%;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
        }
        
        .editor-toggle-btn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: #007acc;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 12px 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            z-index: 20;
            transition: all 0.3s ease-in-out;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .editor-toggle-btn:hover {
            background: #1177bb;
        }

        .editor-toggle-btn:active {
            background: #0e639c;
        }

        /* When editor is open, button moves to right edge */
        .editor-toggle-btn.editor-open {
            left: auto;
            right: 0;
            border-radius: 4px 0 0 4px;
        }
        
        .footer {
            background: #007acc;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        /* Floating Console Window */
        .console-window {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            background: #1e1e1e;
            border: 1px solid #007acc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            z-index: 2000;
            resize: both;
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            max-width: 90vw;
            max-height: 80vh;
        }

        .console-window.minimized {
            height: auto !important;
            min-height: auto;
            resize: none;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        .console-window.hidden {
            display: none;
        }

        .console-title-bar {
            background: #007acc;
            color: white;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .console-title {
            flex: 1;
        }

        .console-controls {
            display: flex;
            gap: 8px;
        }

        .console-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .console-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .console-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #ccc;
            background: #1e1e1e;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }

        .console-window.minimized .console-content {
            display: none;
        }

        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
            white-space: pre-wrap;
            user-select: text;
            -webkit-user-select: text;
        }

        .console-error {
            color: #f14c4c;
        }

        .console-warning {
            color: #ffcc02;
        }

        .console-log {
            color: #ccc;
        }

        .console-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #007acc 50%);
            opacity: 0.5;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        /* Console Open Button (always visible in editor) */
        .console-open-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .console-open-btn:hover {
            background: #1177bb;
            transform: scale(1.1);
        }

        .console-open-btn:active {
            background: #0e639c;
            transform: scale(0.95);
        }

        .console-open-btn.hidden {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        /* Remove media query - same behavior across all devices per requirements */
        /* The editor starts hidden (width: 0%) on all screen sizes */
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">▶ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">🗑 Clear</button>
        <button class="menu-btn" onclick="saveScene()">💾 Save</button>
        <button class="menu-btn" onclick="downloadScene()">⬇ Download</button>
        <button class="menu-btn" onclick="newScene()">📄 New</button>
        <button class="menu-btn" onclick="openDocumentation()">📖 Docs</button>
        <button class="menu-btn" onclick="toggleConsole()">🖥 Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Demo</option>
            <option value="floating-crystal-gems">💎 Floating Crystal Gems</option>
            <option value="physics">⚽ Sphere with Physics</option>
            <option value="path-animation">🛤️ Animated Path Following</option>
            <option value="dynamic-lighting">💡 Dynamic Lighting Scene</option>
            <option value="pbr-materials">✨ PBR Materials Showcase</option>
            <option value="glow-effect">🌟 Glow Effect (Bloom)</option>
            <option value="click-interaction">👆 Click Interaction</option>
            <option value="holographic-torus-array">🌈 Holographic Torus Array</option>
            <option value="particle-fountain">⛲ Particle Fountain</option>
            <option value="fractal-sphere-grid">🔮 Fractal Sphere Grid</option>
            <option value="skybox-fog">🌫️ Skybox with Fog</option>
            <option value="plasma-orb">⚡ Plasma Orb</option>
            <option value="spotlight-showcase">💡 Spotlight Showcase</option>
            <option value="voxel-wormhole">🌀 Infinite Voxel Wormhole</option>
            <option value="tronscape-demo">🌆 Retrowave Tronscape</option>
            <option value="fractal-invader">👾 Fractal Invader</option>
            <option value="space-harrier">🎮 Space Harrier Game</option>
        </select>
        <select class="menu-btn" id="cameraSelector" onchange="switchCamera(this.value)" style="margin-left: 10px;">
            <option value="">Camera: Auto</option>
            <option value="ArcRotateCamera">Arc Rotate (Orbit)</option>
            <option value="FreeCamera">Free Camera (WASD)</option>
            <option value="UniversalCamera">Universal (FPS)</option>
            <option value="FollowCamera">Follow Camera</option>
            <option value="TouchCamera">Touch Camera</option>
            <option value="DeviceOrientationCamera">Device Orientation</option>
            <option value="VirtualJoysticksCamera">Virtual Joysticks</option>
        </select>
        <label style="margin-left: 10px; color: white; cursor: pointer;">
            <input type="checkbox" id="debugCheckbox" onchange="toggleInspector(this.checked)" style="cursor: pointer;">
        </label>
    </div>
    
    <div class="main-container">
        <div class="editor-container" id="editorContainer">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <button class="console-open-btn" id="consoleOpenBtn" title="Open Console">📟</button>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <button class="editor-toggle-btn" id="editorToggleBtn" onclick="toggleEditor()">CODE</button>
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Babylon.js...</div>
        </div>
    </div>
    
    <div class="footer">
        Babylon.js Playground - Powered by WebGL
    </div>
    
    <div class="error-display" id="errorDisplay"></div>

    <!-- Floating Console Window -->
    <div class="console-window" id="consoleWindow">
        <div class="console-title-bar" id="consoleTitleBar">
            <div class="console-title">Console</div>
            <div class="console-controls">
                <button class="console-btn" id="consoleClearBtn" title="Clear Console">🗑</button>
                <button class="console-btn" id="consoleMinimizeBtn" title="Minimize">−</button>
                <button class="console-btn" id="consoleToggleBtn" title="Expand">↕</button>
                <button class="console-btn" id="consoleCloseBtn" title="Close">×</button>
            </div>
        </div>
        <div class="console-content" id="consoleContent"></div>
        <div class="console-resize-handle" id="consoleResizeHandle"></div>
    </div>

    <script>
        let editor;
        let engine;
        let scene;
        let isResizing = false;
        let consoleMessages = [];
        let isEditorOpen = false;

        // Editor toggle functionality - switches between code view (100%) and scene view (100%)
        function toggleEditor() {
            isEditorOpen = !isEditorOpen;
            const editorContainer = document.getElementById('editorContainer');
            const canvasContainer = document.getElementById('canvasContainer');
            const toggleBtn = document.getElementById('editorToggleBtn');

            if (isEditorOpen) {
                // Show code editor (100%), hide scene (0%)
                editorContainer.classList.add('open');
                canvasContainer.classList.add('editor-open');
                toggleBtn.classList.add('editor-open');
                toggleBtn.textContent = 'SCENE';

                // Trigger Monaco layout after transition completes
                setTimeout(() => {
                    if (editor && typeof editor.layout === 'function') {
                        editor.layout();
                    }
                }, 300);
            } else {
                // Show scene (100%), hide code editor (0%)
                editorContainer.classList.remove('open');
                canvasContainer.classList.remove('editor-open');
                toggleBtn.classList.remove('editor-open');
                toggleBtn.textContent = 'CODE';
            }

            // Resize canvas and engine
            if (engine) {
                setTimeout(() => engine.resize(), 350);
            }
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Initialize Monaco Editor with enhanced error handling and fallback
        console.log('Starting Monaco Editor initialization...');
        
        // Set longer timeout for CDN loading
        let monacoTimeout = setTimeout(() => {
            console.error('❌ Monaco Editor CDN loading timeout - creating fallback editor');
            createFallbackEditor();
        }, 10000); // 10 second timeout
        
        require.config({ 
            paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' },
            waitSeconds: 30 // Increase wait time for CDN
        });
        
        require(['vs/editor/editor.main'], function () {
            clearTimeout(monacoTimeout); // Cancel timeout since loading succeeded
            console.log('✅ Monaco modules loaded successfully, creating editor...');
            
            try {
                const editorContainer = document.getElementById('monaco-editor');
                if (!editorContainer) {
                    throw new Error('Monaco editor container not found');
                }
                
                editor = monaco.editor.create(editorContainer, {
                    value: getDefaultCode(),
                    language: 'typescript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('✅ Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible with multiple references
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                // Enhanced readiness check with multiple verification steps
                function verifyAndMarkReady() {
                    console.log('🔍 Verifying Monaco editor readiness...');
                    console.log('- Editor instance:', !!editor);
                    console.log('- Editor model:', !!editor.getModel());
                    console.log('- setValue function:', typeof editor.setValue === 'function');
                    console.log('- getValue function:', typeof editor.getValue === 'function');
                    console.log('- DOM ready:', document.readyState);
                    
                    if (editor && editor.getModel && 
                        typeof editor.setValue === 'function' && 
                        typeof editor.getValue === 'function') {
                        
                        // Final functional test
                        try {
                            const testContent = editor.getValue();
                            editor.layout(); // Trigger layout calculation
                            console.log('✅ Monaco functional test passed - content length:', testContent.length);
                            
                            // Mark as ready
                            window.editorReady = true;
                            console.log('🎯 MONACO EDITOR MARKED AS READY FOR INJECTION');
                            
                            // Initialize Babylon after Monaco is confirmed ready
                            initializeBabylon();
                            
                        } catch (testError) {
                            console.error('❌ Monaco functional test failed:', testError);
                            setTimeout(verifyAndMarkReady, 500); // Retry
                        }
                    } else {
                        console.warn('⚠️ Monaco not fully ready yet, retrying...');
                        setTimeout(verifyAndMarkReady, 500); // Retry
                    }
                }
                
                // Start verification process with initial delay
                setTimeout(verifyAndMarkReady, 1000);
                
            } catch (editorError) {
                console.error('❌ Failed to create Monaco editor:', editorError);
                createFallbackEditor();
            }
        }, function(error) {
            clearTimeout(monacoTimeout);
            console.error('❌ Failed to load Monaco from CDN:', error);
            createFallbackEditor();
        });
        
        // Fallback editor function
        function createFallbackEditor() {
            console.log('🔧 Creating fallback textarea editor...');
            
            const editorContainer = document.getElementById('monaco-editor');
            if (!editorContainer) {
                console.error('❌ Editor container not found');
                return;
            }
            
            // Create a textarea fallback
            editorContainer.innerHTML = '<textarea id="fallback-editor" style="width: 100%; height: 100%; background: #1e1e1e; color: #fff; font-family: \'Monaco\', \'Consolas\', monospace; font-size: 14px; border: none; outline: none; padding: 10px;"></textarea>';
            
            const textarea = document.getElementById('fallback-editor');
            if (textarea) {
                textarea.value = getDefaultCode();
                
                // Create minimal editor interface
                window.editor = {
                    setValue: (code) => { textarea.value = code; },
                    getValue: () => textarea.value,
                    getModel: () => ({ setValue: (code) => textarea.value = code }),
                    layout: () => {},
                    focus: () => textarea.focus(),
                    setPosition: () => {},
                    onDidChangeModelContent: (callback) => {
                        textarea.addEventListener('input', callback);
                        return { dispose: () => {} };
                    }
                };
                
                window.monacoEditor = window.editor;
                window.codeEditor = window.editor;
                
                // Auto-save on changes
                textarea.addEventListener('input', () => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Mark as ready
                window.editorReady = true;
                console.log('✅ Fallback editor ready for injection');
                
                // Initialize Babylon
                initializeBabylon();
            }
        }
        
        // Initialize Babylon.js
        function initializeBabylon() {
            console.log('Initializing Babylon.js...');

            // Check if BABYLON is loaded
            if (typeof BABYLON === 'undefined') {
                console.error('❌ BABYLON is not defined! Waiting for library to load...');
                setTimeout(initializeBabylon, 100); // Retry after 100ms
                return;
            }

            console.log('✅ BABYLON library loaded successfully');
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                disableWebGL2Support: false
            });
            
            console.log('Babylon.js engine created');
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Create default scene
            createDefaultScene();
            
            // Render loop
            engine.runRenderLoop(() => {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });
            
            console.log('Babylon.js render loop started');
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Checking components before signaling ready...');
                console.log('Editor available:', typeof editor !== 'undefined' && !!editor);
                console.log('Editor ready flag:', !!window.editorReady);
                console.log('Engine available:', !!engine);
                console.log('BABYLON available:', !!BABYLON);
                
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!engine 
                });
                console.log('Playground fully initialized');
            }, 1500);  // Give even more time for Monaco to be fully ready
        }
        
        function getDefaultCode() {
            return `// Welcome to Babylon.js Playground!
// Create your 3D scene using TypeScript/JavaScript

const createScene = () => {
    // Create scene
    const scene = new BABYLON.Scene(engine);
    
    // Create camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    
    // Attach camera controls - modern API
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    } else if (scene.actionManager) {
        scene.actionManager = new BABYLON.ActionManager(scene);
    }
    
    // Create light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;
    
    // Create sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;
    
    // Create ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    
    console.log("Scene created with camera:", !!camera, "light:", !!light);
    
    return scene;
};

// Execute the scene creation
const scene = createScene();`;
        }
        
        function createDefaultScene() {
            try {
                // Clear existing scene
                if (scene) {
                    scene.dispose();
                }
                
                // Execute user code
                const userCode = editor ? editor.getValue() : getDefaultCode();
                executeUserCode(userCode);
                
                hideError();
            } catch (error) {
                showError('Scene Creation Error: ' + error.message);
                console.error('Scene creation error:', error);
            }
        }
        
        function cleanBabylonJSCode(code) {
            console.log('🧹 Cleaning Babylon.js code - converting Color3 static properties to constructors');
            let cleanedCode = code;

            // Map of Color3 static properties to RGB constructor values
            const colorReplacements = {
                // Common colors - with parentheses (function call style)
                'Color3.Red()': 'new Color3(1, 0, 0)',
                'Color3.Green()': 'new Color3(0, 1, 0)',
                'Color3.Blue()': 'new Color3(0, 0, 1)',
                'Color3.Yellow()': 'new Color3(1, 1, 0)',
                'Color3.Orange()': 'new Color3(1, 0.5, 0)',
                'Color3.Purple()': 'new Color3(0.5, 0, 1)',
                'Color3.Magenta()': 'new Color3(1, 0, 1)',
                'Color3.Cyan()': 'new Color3(0, 1, 1)',
                'Color3.White()': 'new Color3(1, 1, 1)',
                'Color3.Black()': 'new Color3(0, 0, 0)',
                'Color3.Gray()': 'new Color3(0.5, 0.5, 0.5)',
                'Color3.Teal()': 'new Color3(0, 0.5, 0.5)',

                // BABYLON namespace versions - with parentheses
                'BABYLON.Color3.Red()': 'new BABYLON.Color3(1, 0, 0)',
                'BABYLON.Color3.Green()': 'new BABYLON.Color3(0, 1, 0)',
                'BABYLON.Color3.Blue()': 'new BABYLON.Color3(0, 0, 1)',
                'BABYLON.Color3.Yellow()': 'new BABYLON.Color3(1, 1, 0)',
                'BABYLON.Color3.Orange()': 'new BABYLON.Color3(1, 0.5, 0)',
                'BABYLON.Color3.Purple()': 'new BABYLON.Color3(0.5, 0, 1)',
                'BABYLON.Color3.Magenta()': 'new BABYLON.Color3(1, 0, 1)',
                'BABYLON.Color3.Cyan()': 'new BABYLON.Color3(0, 1, 1)',
                'BABYLON.Color3.White()': 'new BABYLON.Color3(1, 1, 1)',
                'BABYLON.Color3.Black()': 'new BABYLON.Color3(0, 0, 0)',
                'BABYLON.Color3.Gray()': 'new BABYLON.Color3(0.5, 0.5, 0.5)',
                'BABYLON.Color3.Teal()': 'new BABYLON.Color3(0, 0.5, 0.5)',

                // Without parentheses (property access style)
                'Color3.Red': 'new Color3(1, 0, 0)',
                'Color3.Green': 'new Color3(0, 1, 0)',
                'Color3.Blue': 'new Color3(0, 0, 1)',
                'Color3.Yellow': 'new Color3(1, 1, 0)',
                'Color3.Orange': 'new Color3(1, 0.5, 0)',
                'Color3.Purple': 'new Color3(0.5, 0, 1)',
                'Color3.Magenta': 'new Color3(1, 0, 1)',
                'Color3.Cyan': 'new Color3(0, 1, 1)',
                'Color3.White': 'new Color3(1, 1, 1)',
                'Color3.Black': 'new Color3(0, 0, 0)',
                'Color3.Gray': 'new Color3(0.5, 0.5, 0.5)',
                'Color3.Teal': 'new Color3(0, 0.5, 0.5)',

                // BABYLON namespace versions - without parentheses
                'BABYLON.Color3.Red': 'new BABYLON.Color3(1, 0, 0)',
                'BABYLON.Color3.Green': 'new BABYLON.Color3(0, 1, 0)',
                'BABYLON.Color3.Blue': 'new BABYLON.Color3(0, 0, 1)',
                'BABYLON.Color3.Yellow': 'new BABYLON.Color3(1, 1, 0)',
                'BABYLON.Color3.Orange': 'new BABYLON.Color3(1, 0.5, 0)',
                'BABYLON.Color3.Purple': 'new BABYLON.Color3(0.5, 0, 1)',
                'BABYLON.Color3.Magenta': 'new BABYLON.Color3(1, 0, 1)',
                'BABYLON.Color3.Cyan': 'new BABYLON.Color3(0, 1, 1)',
                'BABYLON.Color3.White': 'new BABYLON.Color3(1, 1, 1)',
                'BABYLON.Color3.Black': 'new BABYLON.Color3(0, 0, 0)',
                'BABYLON.Color3.Gray': 'new BABYLON.Color3(0.5, 0.5, 0.5)',
                'BABYLON.Color3.Teal': 'new BABYLON.Color3(0, 0.5, 0.5)'
            };

            // First pass: Replace function call style (with parentheses) - more specific
            for (const [oldColor, newColor] of Object.entries(colorReplacements)) {
                if (oldColor.includes('()')) {
                    const regex = new RegExp(oldColor.replace(/\./g, '\\.').replace(/\(/g, '\\(').replace(/\)/g, '\\)'), 'g');
                    const beforeCount = (cleanedCode.match(regex) || []).length;
                    if (beforeCount > 0) {
                        cleanedCode = cleanedCode.replace(regex, newColor);
                        console.log(`  ✅ Replaced ${beforeCount} instances of ${oldColor} → ${newColor}`);
                    }
                }
            }

            // Second pass: Replace property access style (without parentheses)
            // Use word boundaries to avoid replacing Color3.Red when it's part of Color3.Red()
            for (const [oldColor, newColor] of Object.entries(colorReplacements)) {
                if (!oldColor.includes('()')) {
                    // Use word boundary (\b) to match only complete property names
                    const regex = new RegExp(oldColor.replace(/\./g, '\\.') + '\\b', 'g');
                    const beforeCount = (cleanedCode.match(regex) || []).length;
                    if (beforeCount > 0) {
                        cleanedCode = cleanedCode.replace(regex, newColor);
                        console.log(`  ✅ Replaced ${beforeCount} instances of ${oldColor} → ${newColor}`);
                    }
                }
            }

            console.log('🧹 Babylon.js code cleaning complete');
            return cleanedCode;
        }

        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING USER CODE ===');

                // Check if BABYLON is loaded
                if (typeof BABYLON === 'undefined') {
                    const error = 'BABYLON library not loaded. Please wait for initialization to complete.';
                    console.error('❌', error);
                    showError(error);
                    return;
                }

                console.log('Code to execute (original):', code);

                // Clean Color3 static properties before execution
                code = cleanBabylonJSCode(code);
                console.log('Code to execute (cleaned):', code);

                // Clear previous console messages for new execution
                clearConsole();
                
                // Dispose existing scene if any
                if (scene) {
                    console.log('Disposing existing scene');
                    scene.dispose();
                    scene = null;
                }
                
                // Make sure canvas is available globally
                const canvasElement = document.getElementById('renderCanvas');
                if (!canvasElement) {
                    throw new Error('Canvas element not found');
                }
                
                // Make variables available globally for user code
                window.canvas = canvasElement;
                window.engine = engine;
                window.BABYLON = BABYLON;
                
                console.log('Canvas available:', !!window.canvas);
                console.log('Engine available:', !!window.engine);
                console.log('BABYLON available:', !!window.BABYLON);
                
                // Execute the code in the global context with proper error handling
                try {
                    // Create a safer execution context
                    const executeCode = new Function('canvas', 'engine', 'BABYLON', 
                        `
                        try {
                            ${code}
                            if (typeof scene !== 'undefined') {
                                console.log('Scene variable found:', !!scene);
                                return scene;
                            } else {
                                console.error('No scene variable found in executed code');
                                return null;
                            }
                        } catch (execError) {
                            console.error('Code execution error:', execError);
                            throw execError;
                        }
                        `
                    );
                    
                    // Execute with proper context
                    scene = executeCode(canvasElement, engine, BABYLON);
                    
                } catch (execError) {
                    console.error('Function execution failed:', execError);
                    throw execError;
                }
                
                if (!scene) {
                    throw new Error('Scene creation failed - no scene object returned');
                }
                
                console.log('✅ Scene created successfully:', scene);
                console.log('Scene cameras:', scene.cameras?.length || 0);
                console.log('Scene meshes:', scene.meshes?.length || 0);
                console.log('Scene lights:', scene.lights?.length || 0);
                
                // Force a render update
                if (engine && scene) {
                    console.log('Forcing scene render...');
                    scene.render();
                    engine.resize();
                }
                
                // Hide any error displays
                hideError();
                
                // Clear console and show success
                setTimeout(() => {
                    console.log('🎉 NEW SCENE LOADED SUCCESSFULLY!');
                    addConsoleMessage('log', '🎉 Scene loaded with ' + (scene.meshes?.length || 0) + ' objects');

                    // Ensure the scene is actively rendering
                    if (scene.activeCamera) {
                        console.log('Active camera found, scene should be rendering');

                        // Detect and update camera selector
                        detectCurrentCamera();
                    } else {
                        console.warn('No active camera found!');
                    }
                }, 100);

                // Notify Swift about successful scene creation
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('❌ executeUserCode failed:', errorMsg);
                console.error('Error stack:', error.stack);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Fall back to default scene on error
                console.log('Falling back to default scene...');
                try {
                    scene = createDefaultBabylonScene();
                } catch (fallbackError) {
                    console.error('Even fallback failed:', fallbackError);
                }
            }
        }
        
        // Create a simple fallback scene
        function createDefaultBabylonScene() {
            console.log('Creating fallback default scene');
            const fallbackScene = new BABYLON.Scene(engine);
            
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), fallbackScene);
            camera.setTarget(BABYLON.Vector3.Zero());
            if (camera.attachControls) {
                camera.attachControls(canvas, true);
            }
            
            const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), fallbackScene);
            light.intensity = 0.7;
            
            const sphere = BABYLON.MeshBuilder.CreateSphere("fallback", {diameter: 2}, fallbackScene);
            sphere.position.y = 1;
            
            console.log('Fallback scene created');
            return fallbackScene;
        }
        
        // Playground functions exposed to Swift
        function runCode() {
            console.log('Run code button pressed');
            createDefaultScene();
            notifySwift('codeRun', {});
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function openDocumentation() {
            // Open Babylon.js documentation in Safari
            window.location.href = 'https://doc.babylonjs.com/';
        }
        
        // Floating Console Window Management
        let consoleState = {
            x: null,
            y: null,
            width: 400,
            height: 300,
            minimized: false,
            hidden: false
        };

        function initFloatingConsole() {
            const consoleWindow = document.getElementById('consoleWindow');
            const titleBar = document.getElementById('consoleTitleBar');
            const clearBtn = document.getElementById('consoleClearBtn');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');
            const toggleBtn = document.getElementById('consoleToggleBtn');
            const closeBtn = document.getElementById('consoleCloseBtn');
            const resizeHandle = document.getElementById('consoleResizeHandle');
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');

            // Safety check - return if elements don't exist yet
            if (!consoleWindow || !titleBar || !clearBtn || !minimizeBtn || !toggleBtn || !closeBtn || !resizeHandle || !consoleOpenBtn) {
                console.warn('Console elements not ready yet, skipping initialization');
                return;
            }

            // Load saved state from localStorage
            const saved = localStorage.getItem('babylonjs_console_state');
            if (saved) {
                consoleState = { ...consoleState, ...JSON.parse(saved) };
                applyConsoleState();
            }

            // Clear button
            clearBtn.addEventListener('click', () => {
                clearConsole();
            });

            // Minimize button
            minimizeBtn.addEventListener('click', () => {
                consoleState.minimized = !consoleState.minimized;
                consoleWindow.classList.toggle('minimized', consoleState.minimized);
                minimizeBtn.textContent = consoleState.minimized ? '+' : '−';
                saveConsoleState();
            });

            // Toggle/Expand button
            toggleBtn.addEventListener('click', () => {
                if (consoleState.minimized) {
                    consoleState.minimized = false;
                    consoleWindow.classList.remove('minimized');
                    minimizeBtn.textContent = '−';
                }
                saveConsoleState();
            });

            // Close button
            closeBtn.addEventListener('click', () => {
                consoleState.hidden = true;
                consoleWindow.classList.add('hidden');
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Dragging
            let isDragging = false;
            let dragStartX, dragStartY, dragStartLeft, dragStartTop;

            titleBar.addEventListener('mousedown', startDrag);
            titleBar.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                if (e.target.closest('.console-btn')) return;
                isDragging = true;

                const rect = consoleWindow.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                dragStartX = clientX;
                dragStartY = clientY;
                dragStartLeft = rect.left;
                dragStartTop = rect.top;

                e.preventDefault();
            }

            function doDrag(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - dragStartX;
                const deltaY = clientY - dragStartY;

                consoleState.x = dragStartLeft + deltaX;
                consoleState.y = dragStartTop + deltaY;

                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';

                e.preventDefault();
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);

            // Resizing
            let isResizing = false;
            let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;

            resizeHandle.addEventListener('mousedown', startResize);
            resizeHandle.addEventListener('touchstart', startResize, { passive: false });

            function startResize(e) {
                isResizing = true;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                resizeStartX = clientX;
                resizeStartY = clientY;
                resizeStartWidth = consoleWindow.offsetWidth;
                resizeStartHeight = consoleWindow.offsetHeight;

                e.preventDefault();
                e.stopPropagation();
            }

            function doResize(e) {
                if (!isResizing) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - resizeStartX;
                const deltaY = clientY - resizeStartY;

                consoleState.width = Math.max(300, Math.min(resizeStartWidth + deltaX, window.innerWidth * 0.9));
                consoleState.height = Math.max(200, Math.min(resizeStartHeight + deltaY, window.innerHeight * 0.8));

                consoleWindow.style.width = consoleState.width + 'px';
                consoleWindow.style.height = consoleState.height + 'px';

                e.preventDefault();
            }

            function stopResize() {
                if (isResizing) {
                    isResizing = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchend', stopResize);

            // Console Open Button (already declared at top of function)
            consoleOpenBtn.addEventListener('click', () => {
                consoleState.hidden = false;
                consoleState.minimized = false;
                consoleWindow.classList.remove('hidden');
                consoleWindow.classList.remove('minimized');
                minimizeBtn.textContent = '−';
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Update button visibility based on console state
            updateConsoleOpenButtonVisibility();
        }

        function updateConsoleOpenButtonVisibility() {
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');
            const consoleWindow = document.getElementById('consoleWindow');

            // Show button only when console is hidden
            if (consoleState.hidden) {
                consoleOpenBtn.classList.remove('hidden');
            } else {
                consoleOpenBtn.classList.add('hidden');
            }
        }

        function applyConsoleState() {
            const consoleWindow = document.getElementById('consoleWindow');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');

            if (consoleState.x !== null && consoleState.y !== null) {
                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';
            }

            consoleWindow.style.width = consoleState.width + 'px';
            consoleWindow.style.height = consoleState.height + 'px';

            consoleWindow.classList.toggle('minimized', consoleState.minimized);
            consoleWindow.classList.toggle('hidden', consoleState.hidden);
            minimizeBtn.textContent = consoleState.minimized ? '+' : '−';

            updateConsoleOpenButtonVisibility();
        }

        function saveConsoleState() {
            localStorage.setItem('babylonjs_console_state', JSON.stringify(consoleState));
        }

        function toggleConsole() {
            consoleState.hidden = !consoleState.hidden;
            document.getElementById('consoleWindow').classList.toggle('hidden', consoleState.hidden);
            saveConsoleState();
            updateConsoleOpenButtonVisibility();
            if (!consoleState.hidden && consoleMessages.length === 0) {
                console.log('Console opened - no messages yet');
            }
        }

        // Initialize console on page load
        window.addEventListener('DOMContentLoaded', initFloatingConsole);

        // Camera switching functionality
        function switchCamera(cameraType) {
            if (!scene) {
                console.warn('No scene available for camera switching');
                return;
            }

            if (!cameraType || cameraType === '') {
                console.log('Camera set to Auto - using scene default');
                return;
            }

            console.log('Switching to camera type:', cameraType);

            // Store current camera position if it exists
            let currentPosition = scene.activeCamera ? scene.activeCamera.position.clone() : new BABYLON.Vector3(0, 5, -10);
            let currentTarget = scene.activeCamera && scene.activeCamera.target ? scene.activeCamera.target.clone() : BABYLON.Vector3.Zero();

            // Dispose old camera if it exists
            if (scene.activeCamera) {
                const oldCamera = scene.activeCamera;
                scene.activeCamera = null;
                oldCamera.dispose();
            }

            let newCamera;

            try {
                switch(cameraType) {
                    case 'ArcRotateCamera':
                        newCamera = new BABYLON.ArcRotateCamera("arcRotate", Math.PI / 2, Math.PI / 2.5, 10, currentTarget, scene);
                        newCamera.attachControl(canvas, true);
                        newCamera.wheelPrecision = 50;
                        newCamera.lowerRadiusLimit = 2;
                        newCamera.upperRadiusLimit = 100;
                        break;

                    case 'FreeCamera':
                        newCamera = new BABYLON.FreeCamera("free", currentPosition, scene);
                        newCamera.setTarget(currentTarget);
                        newCamera.attachControl(canvas, true);
                        newCamera.keysUp.push(87); // W
                        newCamera.keysDown.push(83); // S
                        newCamera.keysLeft.push(65); // A
                        newCamera.keysRight.push(68); // D
                        newCamera.speed = 0.5;
                        break;

                    case 'UniversalCamera':
                        newCamera = new BABYLON.UniversalCamera("universal", currentPosition, scene);
                        newCamera.setTarget(currentTarget);
                        newCamera.attachControl(canvas, true);
                        newCamera.keysUp.push(87); // W
                        newCamera.keysDown.push(83); // S
                        newCamera.keysLeft.push(65); // A
                        newCamera.keysRight.push(68); // D
                        newCamera.speed = 0.5;
                        newCamera.angularSensibility = 2000;
                        break;

                    case 'FollowCamera':
                        newCamera = new BABYLON.FollowCamera("follow", currentPosition, scene);
                        // Try to find a mesh to follow
                        const meshes = scene.meshes.filter(m => m.name !== 'skyBox' && m.name !== 'ground');
                        if (meshes.length > 0) {
                            newCamera.lockedTarget = meshes[0];
                            newCamera.radius = 10;
                            newCamera.heightOffset = 5;
                            newCamera.rotationOffset = 180;
                            newCamera.cameraAcceleration = 0.05;
                            newCamera.maxCameraSpeed = 10;
                        } else {
                            console.warn('No suitable mesh found for FollowCamera, using default position');
                            newCamera.position = currentPosition;
                        }
                        newCamera.attachControl(canvas, true);
                        break;

                    case 'TouchCamera':
                        newCamera = new BABYLON.TouchCamera("touch", currentPosition, scene);
                        newCamera.setTarget(currentTarget);
                        newCamera.attachControl(canvas, true);
                        newCamera.speed = 0.5;
                        newCamera.touchAngularSensibility = 5000;
                        break;

                    case 'DeviceOrientationCamera':
                        newCamera = new BABYLON.DeviceOrientationCamera("deviceOrientation", currentPosition, scene);
                        newCamera.setTarget(currentTarget);
                        newCamera.attachControl(canvas, true);
                        break;

                    case 'VirtualJoysticksCamera':
                        newCamera = new BABYLON.VirtualJoysticksCamera("virtualJoysticks", currentPosition, scene);
                        newCamera.setTarget(currentTarget);
                        newCamera.attachControl(canvas, true);
                        break;

                    default:
                        console.warn('Unknown camera type:', cameraType);
                        return;
                }

                scene.activeCamera = newCamera;
                console.log('Camera switched successfully to:', cameraType);

            } catch(error) {
                console.error('Error switching camera:', error);
                // Fallback to a basic camera
                const fallbackCamera = new BABYLON.FreeCamera("fallback", currentPosition, scene);
                fallbackCamera.setTarget(currentTarget);
                fallbackCamera.attachControl(canvas, true);
                scene.activeCamera = fallbackCamera;
            }
        }

        // Inspector toggle functionality
        let inspectorVisible = false;
        function toggleInspector(checked) {
            if (!scene) {
                console.warn('No scene available for inspector');
                document.getElementById('debugCheckbox').checked = false;
                return;
            }

            inspectorVisible = checked;

            if (checked) {
                // Show inspector
                console.log('Opening Babylon.js Inspector...');
                scene.debugLayer.show({
                    embedMode: false, // Overlay mode
                    overlay: true,
                    showExplorer: true,
                    showInspector: true,
                    handleResize: true,
                    enablePopup: false
                });
            } else {
                // Hide inspector
                console.log('Closing Babylon.js Inspector...');
                scene.debugLayer.hide();
            }
        }

        // Auto-detect camera type when scene changes
        function detectCurrentCamera() {
            if (!scene || !scene.activeCamera) {
                document.getElementById('cameraSelector').value = '';
                return;
            }

            const cameraType = scene.activeCamera.getClassName();
            const selector = document.getElementById('cameraSelector');

            // Try to match the camera type to dropdown options
            const options = Array.from(selector.options);
            const matchingOption = options.find(opt => opt.value === cameraType);

            if (matchingOption) {
                selector.value = cameraType;
                console.log('Detected camera type:', cameraType);
            } else {
                selector.value = ''; // Auto
                console.log('Camera type not in dropdown:', cameraType);
            }
        }

        function loadExample(exampleId) {
            if (!exampleId) return;

            const examples = {
                'floating-crystal-gems': getFloatingCrystalGemsCode(),
                'physics': getPhysicsCode(),
                'path-animation': getPathAnimationCode(),
                'dynamic-lighting': getDynamicLightingCode(),
                'pbr-materials': getPBRMaterialsCode(),
                'glow-effect': getGlowEffectCode(),
                'click-interaction': getClickInteractionCode(),
                'holographic-torus-array': getHolographicTorusArrayCode(),
                'particle-fountain': getParticleFountainCode(),
                'fractal-sphere-grid': getFractalSphereGridCode(),
                'skybox-fog': getSkyboxFogCode(),
                'plasma-orb': getPlasmaOrbCode(),
                'spotlight-showcase': getSpotlightShowcaseCode(),
                'voxel-wormhole': getVoxelWormholeCode(),
                'tronscape-demo': getTronscapeDemoCode(),
                'fractal-invader': getFractalInvaderCode(),
                'space-harrier': getSpaceHarrierCode()
            };

            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion function for AI assistance with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('🎯 insertCodeAtCursor called with code length:', codeString.length);
            console.log('🔍 Current editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('✅ Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('✅ Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('❌ Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('⚠️ Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        // Enhanced function to completely replace editor content with multi-level retry
        function setFullEditorContent(codeString) {
            console.log('🎯 setFullEditorContent called with code length:', codeString.length);
            console.log('🔍 Editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('📝 Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('✅ Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('⚠️ Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('📝 Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('✅ Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('📝 Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('✅ Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('❌ Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`🎉 Content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('🚀 Auto-running the injected code...');
                                runCode();
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true 
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`❌ Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('❌ All injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All injection strategies failed'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management functions
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50); // Keep last 50 messages
            }
            updateConsoleDisplay();
        }
        
        function updateConsoleDisplay() {
            const consoleContent = document.getElementById('consoleContent');
            if (consoleContent && consoleMessages.length > 0) {
                consoleContent.innerHTML = consoleMessages.map(msg =>
                    `<div class="console-message console-${msg.type}">${escapeHtml(msg.message)}</div>`
                ).join('');
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Example code templates
        // Example Code Functions - Updated from Library3D examples
        function getFloatingCrystalGemsCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 12, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.8;

    // Add glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 0.5;

    // Create three floating crystals
    const colors = [
        new BABYLON.Color3(1, 0.2, 0.6),  // Pink
        new BABYLON.Color3(0.2, 0.6, 1),  // Blue
        new BABYLON.Color3(1, 0.8, 0.2)   // Gold
    ];

    for (let i = 0; i < 3; i++) {
        const crystal = BABYLON.MeshBuilder.CreatePolyhedron("crystal" + i, {type: 1, size: 1.2}, scene);
        crystal.position.x = (i - 1) * 3;
        crystal.position.y = 1;

        const material = new BABYLON.PBRMaterial("mat" + i, scene);
        material.albedoColor = colors[i];
        material.metallic = 0.9;
        material.roughness = 0.1;
        material.emissiveColor = colors[i];
        material.emissiveIntensity = 0.3;
        crystal.material = material;

        // Floating animation
        const startY = crystal.position.y;
        scene.registerBeforeRender(() => {
            crystal.rotation.y += 0.005 + i * 0.003;
            crystal.position.y = startY + Math.sin(Date.now() * 0.001 + i) * 0.3;
        });
    }

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 15, height: 15}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
    groundMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ground.material = groundMat;

    return scene;
};
const scene = createScene();`;
        }
        
        function getLightingDemoCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Lights - demonstrating different light types
    const hemisphericLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    hemisphericLight.intensity = 0.3;

    const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -1, -1), scene);
    directionalLight.position = new BABYLON.Vector3(10, 10, 10);
    directionalLight.intensity = 0.7;

    // Objects
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position = new BABYLON.Vector3(-2, 1, 0);

    const box = BABYLON.MeshBuilder.CreateBox("box", {size: 2}, scene);
    box.position = new BABYLON.Vector3(2, 1, 0);

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);

    console.log("Lighting demo scene created successfully");

    return scene;
};

const scene = createScene();`;
        }
        
        function getMaterialsDemoCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Light
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Materials
    const redMaterial = new BABYLON.StandardMaterial("redMaterial", scene);
    redMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0);

    const blueMaterial = new BABYLON.StandardMaterial("blueMaterial", scene);
    blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1);
    blueMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

    const greenMaterial = new BABYLON.StandardMaterial("greenMaterial", scene);
    greenMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
    greenMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);

    // Objects with materials
    const sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {diameter: 2}, scene);
    sphere1.position = new BABYLON.Vector3(-3, 1, 0);
    sphere1.material = redMaterial;

    const sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {diameter: 2}, scene);
    sphere2.position = new BABYLON.Vector3(0, 1, 0);
    sphere2.material = blueMaterial;

    const sphere3 = BABYLON.MeshBuilder.CreateSphere("sphere3", {diameter: 2}, scene);
    sphere3.position = new BABYLON.Vector3(3, 1, 0);
    sphere3.material = greenMaterial;

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);

    return scene;
};

const scene = createScene();`;
        }

        function getGlowLayerCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

    // Camera
    const camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 3, 15, BABYLON.Vector3.Zero(), scene);

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    camera.lowerRadiusLimit = 5;
    camera.upperRadiusLimit = 30;

    // Lighting
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.5;

    // Create glow layer for bloom effect
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.0;

    // Create emissive materials for glowing objects
    const colors = [
        new BABYLON.Color3(1, 0.2, 0.2),    // Red
        new BABYLON.Color3(0.2, 1, 0.2),    // Green
        new BABYLON.Color3(0.2, 0.2, 1),    // Blue
        new BABYLON.Color3(1, 1, 0.2),      // Yellow
        new BABYLON.Color3(1, 0.2, 1)       // Magenta
    ];

    // Create glowing spheres in a circle
    for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const x = Math.cos(angle) * 4;
        const z = Math.sin(angle) * 4;

        const sphere = BABYLON.MeshBuilder.CreateSphere(\`sphere\${i}\`, {diameter: 1.5}, scene);
        sphere.position = new BABYLON.Vector3(x, 0, z);

        const material = new BABYLON.StandardMaterial(\`mat\${i}\`, scene);
        material.diffuseColor = colors[i];
        material.emissiveColor = colors[i];
        material.specularColor = new BABYLON.Color3(0, 0, 0);
        sphere.material = material;

        // Animate spheres
        sphere.metadata = {
            initialY: 0,
            speed: 0.5 + Math.random() * 0.5,
            offset: i * Math.PI * 0.4
        };
    }

    // Create central glowing torus
    const torus = BABYLON.MeshBuilder.CreateTorus("torus", {
        diameter: 3,
        thickness: 0.5,
        tessellation: 32
    }, scene);
    torus.position.y = 0;

    const torusMat = new BABYLON.StandardMaterial("torusMat", scene);
    torusMat.diffuseColor = new BABYLON.Color3(0.3, 0.6, 1.0);
    torusMat.emissiveColor = new BABYLON.Color3(0.3, 0.6, 1.0);
    torusMat.specularColor = new BABYLON.Color3(0, 0, 0);
    torus.material = torusMat;

    // Ground plane
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 20}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
    groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
    ground.material = groundMat;

    // Animation
    scene.registerBeforeRender(() => {
        const time = performance.now() * 0.001;

        // Animate spheres
        scene.meshes.forEach(mesh => {
            if (mesh.name.startsWith('sphere')) {
                const meta = mesh.metadata;
                mesh.position.y = meta.initialY + Math.sin(time * meta.speed + meta.offset) * 1.5;
            }
        });

        // Rotate torus
        torus.rotation.x += 0.005;
        torus.rotation.y += 0.01;
    });

    console.log("✨ Glow layer postprocessing scene created!");

    return scene;
};

const scene = createScene();`;
        }

        function getBlurPostProcessCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);

    // Camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    // Attach camera controls safely
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Lighting
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const directionalLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
    directionalLight.intensity = 0.5;

    // Create colorful objects
    const colors = [
        new BABYLON.Color3(1, 0.3, 0.3),
        new BABYLON.Color3(0.3, 1, 0.3),
        new BABYLON.Color3(0.3, 0.3, 1)
    ];

    for (let i = 0; i < 3; i++) {
        const box = BABYLON.MeshBuilder.CreateBox(\`box\${i}\`, {size: 1.5}, scene);
        box.position = new BABYLON.Vector3((i - 1) * 3, 1, 0);

        const material = new BABYLON.StandardMaterial(\`mat\${i}\`, scene);
        material.diffuseColor = colors[i];
        material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        box.material = material;

        // Animate rotation
        box.metadata = {speed: 0.01 + i * 0.005};
    }

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 15, height: 15}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ground.material = groundMat;

    // Apply horizontal blur post-process
    const horizontalBlur = new BABYLON.BlurPostProcess(
        "HorizontalBlur",
        new BABYLON.Vector2(1.0, 0),  // Horizontal direction
        10,                            // Kernel size (blur intensity)
        1.0,                           // Sampling ratio
        camera                         // Attach to camera
    );

    // Apply vertical blur post-process
    const verticalBlur = new BABYLON.BlurPostProcess(
        "VerticalBlur",
        new BABYLON.Vector2(0, 1.0),  // Vertical direction
        10,                            // Kernel size
        1.0,                           // Sampling ratio
        camera                         // Attach to camera
    );

    // Animation
    scene.registerBeforeRender(() => {
        scene.meshes.forEach(mesh => {
            if (mesh.name.startsWith('box')) {
                mesh.rotation.x += mesh.metadata.speed;
                mesh.rotation.y += mesh.metadata.speed * 1.5;
            }
        });
    });

    console.log("🌫️ Blur postprocessing scene created!");
    console.log("Blur effects applied to camera - entire scene has depth of field effect");

    return scene;
};

const scene = createScene();`;
        }

        function getBlackAndWhiteCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.5, 0.7, 0.9);

    // Camera
    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 12, BABYLON.Vector3.Zero(), scene);
    camera.attachControls(canvas, true);

    // Lighting
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const directionalLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
    directionalLight.intensity = 0.5;

    // Create colorful scene (will be converted to B&W)
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;

    const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
    sphereMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2);
    sphereMat.specularColor = new BABYLON.Color3(1, 1, 1);
    sphere.material = sphereMat;

    const torus = BABYLON.MeshBuilder.CreateTorus("torus", {diameter: 3, thickness: 0.5}, scene);
    torus.position.y = 1;

    const torusMat = new BABYLON.StandardMaterial("torusMat", scene);
    torusMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 1);
    torusMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    torus.material = torusMat;

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.3);
    ground.material = groundMat;

    // Apply black and white post-process
    const bwPostProcess = new BABYLON.BlackAndWhitePostProcess("bandw", 1.0, camera);

    // Animation
    scene.registerBeforeRender(() => {
        sphere.rotation.y += 0.01;
        torus.rotation.x += 0.005;
        torus.rotation.z += 0.01;
    });

    console.log("⚫⚪ Black and White postprocessing scene created!");
    console.log("All colors converted to grayscale using BlackAndWhitePostProcess");

    return scene;
};

const scene = createScene();`;
        }

        // New Example Code Functions from Library3D
        function getPhysicsCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Enable physics
    const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin());

    // Create sphere with physics
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 5;
    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, {mass: 1, restitution: 0.9}, scene);

    const material = new BABYLON.StandardMaterial("sphereMat", scene);
    material.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
    sphere.material = material;

    // Ground with physics
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0, restitution: 0.9}, scene);

    return scene;
};
const scene = createScene();`;
        }

        function getPathAnimationCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Create a path
    const path = [];
    for (let i = 0; i < 60; i++) {
        path.push(new BABYLON.Vector3(5 * Math.cos(i * 0.1), 0, 5 * Math.sin(i * 0.1)));
    }

    // Create tube along path
    const tube = BABYLON.MeshBuilder.CreateTube("tube", {path: path, radius: 0.1}, scene);

    // Create moving sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1}, scene);
    const material = new BABYLON.StandardMaterial("mat", scene);
    material.diffuseColor = new BABYLON.Color3(1, 0, 0);
    sphere.material = material;

    // Animation
    let alpha = 0;
    scene.registerBeforeRender(() => {
        alpha += 0.02;
        const index = Math.floor(alpha) % path.length;
        sphere.position = path[index];
    });

    return scene;
};
const scene = createScene();`;
        }

        function getDynamicLightingCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.2);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Create multiple point lights
    const light1 = new BABYLON.PointLight("light1", new BABYLON.Vector3(3, 3, 0), scene);
    light1.diffuse = new BABYLON.Color3(1, 0, 0);
    light1.intensity = 0.5;

    const light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(-3, 3, 0), scene);
    light2.diffuse = new BABYLON.Color3(0, 1, 0);
    light2.intensity = 0.5;

    const light3 = new BABYLON.PointLight("light3", new BABYLON.Vector3(0, 3, 3), scene);
    light3.diffuse = new BABYLON.Color3(0, 0, 1);
    light3.intensity = 0.5;

    // Center object
    const box = BABYLON.MeshBuilder.CreateBox("box", {size: 2}, scene);
    const material = new BABYLON.StandardMaterial("mat", scene);
    material.specularColor = new BABYLON.Color3(1, 1, 1);
    box.material = material;

    // Animate lights
    let time = 0;
    scene.registerBeforeRender(() => {
        time += 0.01;
        light1.position.x = 3 * Math.cos(time);
        light1.position.z = 3 * Math.sin(time);
        light2.position.x = 3 * Math.cos(time + 2.09);
        light2.position.z = 3 * Math.sin(time + 2.09);
        light3.position.x = 3 * Math.cos(time + 4.18);
        light3.position.z = 3 * Math.sin(time + 4.18);
    });

    return scene;
};
const scene = createScene();`;
        }

        function getPBRMaterialsCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 1.0;

    // Create spheres with different materials
    for (let i = 0; i < 5; i++) {
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere" + i, {diameter: 2}, scene);
        sphere.position.x = (i - 2) * 3;

        const material = new BABYLON.PBRMaterial("pbr" + i, scene);
        material.albedoColor = new BABYLON.Color3(1, 0.5, 0);
        material.metallic = i / 4; // Varying metallic
        material.roughness = 0.3;
        sphere.material = material;
    }

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 10}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ground.material = groundMat;

    return scene;
};
const scene = createScene();`;
        }

        function getGlowEffectCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);

    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.3;

    // Create glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.0;

    // Create glowing sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
    sphere.position.y = 1;

    const material = new BABYLON.StandardMaterial("mat", scene);
    material.emissiveColor = new BABYLON.Color3(0, 1, 1);
    material.diffuseColor = new BABYLON.Color3(0, 0.3, 0.3);
    sphere.material = material;

    // Animated rotation
    scene.registerBeforeRender(() => {
        sphere.rotation.y += 0.01;
    });

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);

    return scene;
};
const scene = createScene();`;
        }

        function getClickInteractionCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Create boxes
    const colors = [
        new BABYLON.Color3(1, 0, 0),
        new BABYLON.Color3(0, 1, 0),
        new BABYLON.Color3(0, 0, 1)
    ];

    for (let i = 0; i < 3; i++) {
        const box = BABYLON.MeshBuilder.CreateBox("box" + i, {size: 1.5}, scene);
        box.position.x = (i - 1) * 3;
        box.position.y = 1;

        const material = new BABYLON.StandardMaterial("mat" + i, scene);
        material.diffuseColor = colors[i];
        box.material = material;

        // Add click interaction
        box.actionManager = new BABYLON.ActionManager(scene);
        box.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function() {
                    box.scaling = box.scaling.x === 1 ? new BABYLON.Vector3(1.5, 1.5, 1.5) : new BABYLON.Vector3(1, 1, 1);
                }
            )
        );
    }

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);

    return scene;
};
const scene = createScene();`;
        }

        function getHolographicTorusArrayCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0.02, 0.08);

    const camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 3, 20, new BABYLON.Vector3(0, 0, 0), scene);
    camera.lowerRadiusLimit = 10;
    camera.upperRadiusLimit = 40;
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.4;

    // Create intense glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.5;

    // Create array of torus meshes
    const count = 8;
    const toruses = [];

    for (let i = 0; i < count; i++) {
        const torus = BABYLON.MeshBuilder.CreateTorus("torus" + i, {
            diameter: 3,
            thickness: 0.5,
            tessellation: 64
        }, scene);

        torus.position.z = (i - count / 2) * 2;

        // Create rainbow gradient material
        const hue = (i / count) * 360;
        const r = Math.abs(Math.sin((hue) * Math.PI / 180));
        const g = Math.abs(Math.sin((hue + 120) * Math.PI / 180));
        const b = Math.abs(Math.sin((hue + 240) * Math.PI / 180));

        const material = new BABYLON.PBRMaterial("mat" + i, scene);
        material.albedoColor = new BABYLON.Color3(r, g, b);
        material.metallic = 0.95;
        material.roughness = 0.05;
        material.emissiveColor = new BABYLON.Color3(r * 0.8, g * 0.8, b * 0.8);
        material.emissiveIntensity = 0.8;
        torus.material = material;

        toruses.push(torus);
    }

    // Wave animation
    let time = 0;
    scene.registerBeforeRender(() => {
        time += 0.016;

        // Auto-rotate camera
        camera.alpha += 0.002;

        toruses.forEach((torus, i) => {
            const offset = (i / count) * Math.PI * 2;

            // Wave motion
            torus.position.y = Math.sin(time + offset) * 2.5;

            // Rotation
            torus.rotation.x = time * 0.3;
            torus.rotation.z = time * 0.2;

            // Pulsing scale
            const scale = 1 + Math.sin(time + offset) * 0.15;
            torus.scaling = new BABYLON.Vector3(scale, scale, scale);
        });
    });

    return scene;
};
const scene = createScene();`;
        }

        function getParticleFountainCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.15);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.6;

    // Create particle system
    const particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
    particleSystem.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);

    // Fountain emitter
    particleSystem.emitter = new BABYLON.Vector3(0, 0, 0);
    particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5);
    particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 0.5);

    // Colors
    particleSystem.color1 = new BABYLON.Color4(1, 0.2, 0.6, 1.0);
    particleSystem.color2 = new BABYLON.Color4(0.2, 0.6, 1, 1.0);
    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);

    // Size
    particleSystem.minSize = 0.1;
    particleSystem.maxSize = 0.3;

    // Life time
    particleSystem.minLifeTime = 1.0;
    particleSystem.maxLifeTime = 2.0;

    // Emission rate
    particleSystem.emitRate = 300;

    // Blend mode
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

    // Gravity
    particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

    // Direction
    particleSystem.direction1 = new BABYLON.Vector3(-1, 8, -1);
    particleSystem.direction2 = new BABYLON.Vector3(1, 10, 1);

    // Speed
    particleSystem.minEmitPower = 1;
    particleSystem.maxEmitPower = 3;
    particleSystem.updateSpeed = 0.01;

    particleSystem.start();

    // Base platform
    const base = BABYLON.MeshBuilder.CreateCylinder("base", {diameter: 3, height: 0.5}, scene);
    base.position.y = -0.25;
    const baseMat = new BABYLON.StandardMaterial("baseMat", scene);
    baseMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
    base.material = baseMat;

    return scene;
};
const scene = createScene();`;
        }

        function getFractalSphereGridCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);

    const camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 4, 25, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 0.8;

    // Create grid of spheres
    const spheres = [];
    const gridSize = 5;

    for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
            const sphere = BABYLON.MeshBuilder.CreateSphere("sphere" + x + "_" + z, {diameter: 1}, scene);
            sphere.position.x = (x - gridSize / 2) * 2.5;
            sphere.position.z = (z - gridSize / 2) * 2.5;

            // Distance from center for fractal pattern
            const distFromCenter = Math.sqrt(Math.pow(x - gridSize / 2, 2) + Math.pow(z - gridSize / 2, 2));
            const normalizedDist = distFromCenter / (gridSize / 2);

            const material = new BABYLON.PBRMaterial("mat" + x + "_" + z, scene);
            const hue = (x + z) / (gridSize * 2);
            material.albedoColor = new BABYLON.Color3(
                Math.abs(Math.sin(hue * Math.PI * 2)),
                Math.abs(Math.sin((hue + 0.33) * Math.PI * 2)),
                Math.abs(Math.sin((hue + 0.66) * Math.PI * 2))
            );
            material.metallic = 0.9;
            material.roughness = 0.1;
            material.emissiveColor = material.albedoColor;
            material.emissiveIntensity = 0.4;
            sphere.material = material;

            spheres.push({mesh: sphere, dist: normalizedDist, x: x, z: z});
        }
    }

    // Animation
    scene.registerBeforeRender(() => {
        const time = Date.now() * 0.001;

        spheres.forEach(data => {
            const wave = Math.sin(time + data.dist * 3);
            data.mesh.position.y = wave * 1.5;
            data.mesh.rotation.y = time + data.dist;
            const scale = 0.5 + wave * 0.3;
            data.mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
        });
    });

    return scene;
};
const scene = createScene();`;
        }

        function getSkyboxFogCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 3, 20, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    // Skybox
    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000}, scene);
    const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.15);
    skybox.material = skyboxMaterial;

    // Fog
    scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
    scene.fogDensity = 0.02;
    scene.fogColor = new BABYLON.Color3(0.1, 0.05, 0.15);

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.5;

    // Create floating monoliths
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = 10;

        const monolith = BABYLON.MeshBuilder.CreateBox("monolith" + i, {
            width: 1.5,
            height: 5,
            depth: 1.5
        }, scene);

        monolith.position.x = Math.cos(angle) * radius;
        monolith.position.z = Math.sin(angle) * radius;
        monolith.position.y = 2.5;
        monolith.rotation.y = -angle;

        const material = new BABYLON.PBRMaterial("monolithMat" + i, scene);
        material.albedoColor = new BABYLON.Color3(0.3, 0.2, 0.5);
        material.metallic = 0.8;
        material.roughness = 0.2;
        material.emissiveColor = new BABYLON.Color3(0.5, 0.2, 0.8);
        material.emissiveIntensity = 0.3;
        monolith.material = material;
    }

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 50, height: 50}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.05, 0.15);
    groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    ground.material = groundMat;

    return scene;
};
const scene = createScene();`;
        }

        function getPlasmaOrbCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 8, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.3;

    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.8;

    // Main orb
    const orb = BABYLON.MeshBuilder.CreateSphere("orb", {diameter: 3, segments: 64}, scene);
    const orbMat = new BABYLON.PBRMaterial("orbMat", scene);
    orbMat.albedoColor = new BABYLON.Color3(0.5, 0.1, 1);
    orbMat.metallic = 0.95;
    orbMat.roughness = 0.05;
    orbMat.emissiveColor = new BABYLON.Color3(0.8, 0.2, 1);
    orbMat.emissiveIntensity = 1.5;
    orb.material = orbMat;

    // Electric rings
    const rings = [];
    for (let i = 0; i < 3; i++) {
        const ring = BABYLON.MeshBuilder.CreateTorus("ring" + i, {
            diameter: 4 + i * 0.5,
            thickness: 0.05,
            tessellation: 64
        }, scene);

        const ringMat = new BABYLON.StandardMaterial("ringMat" + i, scene);
        ringMat.emissiveColor = new BABYLON.Color3(0, 1, 1);
        ring.material = ringMat;

        rings.push(ring);
    }

    // Point lights
    const light1 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 0, 0), scene);
    light1.diffuse = new BABYLON.Color3(0.8, 0.2, 1);
    light1.intensity = 2;

    // Animation
    scene.registerBeforeRender(() => {
        const time = Date.now() * 0.001;

        // Pulsating orb
        const scale = 1 + Math.sin(time * 2) * 0.1;
        orb.scaling = new BABYLON.Vector3(scale, scale, scale);

        // Rotating rings at different speeds
        rings.forEach((ring, i) => {
            ring.rotation.x = time * (0.5 + i * 0.2);
            ring.rotation.y = time * (0.3 + i * 0.15);
        });

        // Pulsating glow
        gl.intensity = 1.5 + Math.sin(time * 3) * 0.5;

        // Color shift
        const hue = (time * 0.1) % 1;
        orbMat.emissiveColor = new BABYLON.Color3(
            0.5 + Math.sin(hue * Math.PI * 2) * 0.5,
            0.2,
            0.8 + Math.cos(hue * Math.PI * 2) * 0.2
        );
    });

    return scene;
};
const scene = createScene();`;
        }

        function getSpotlightShowcaseCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);

    const camera = new BABYLON.ArcRotateCamera("camera1", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.2;

    // Create three spotlights
    const colors = [
        new BABYLON.Color3(1, 0.2, 0.2),
        new BABYLON.Color3(0.2, 1, 0.2),
        new BABYLON.Color3(0.2, 0.2, 1)
    ];

    const spotlights = [];
    for (let i = 0; i < 3; i++) {
        const spotlight = new BABYLON.SpotLight(
            "spot" + i,
            new BABYLON.Vector3((i - 1) * 4, 8, 0),
            new BABYLON.Vector3(0, -1, 0),
            Math.PI / 3,
            2,
            scene
        );
        spotlight.diffuse = colors[i];
        spotlight.intensity = 3;

        // Shadow generator
        const shadowGenerator = new BABYLON.ShadowGenerator(1024, spotlight);
        shadowGenerator.useBlurExponentialShadowMap = true;

        spotlights.push({light: spotlight, shadow: shadowGenerator});

        // Create object under each spotlight
        const box = BABYLON.MeshBuilder.CreateBox("box" + i, {size: 2}, scene);
        box.position.x = (i - 1) * 4;
        box.position.y = 1;

        const material = new BABYLON.StandardMaterial("mat" + i, scene);
        material.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        material.specularColor = colors[i];
        box.material = material;

        shadowGenerator.addShadowCaster(box);
    }

    // Ground with shadow receiving
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 10}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25);
    ground.material = groundMat;
    ground.receiveShadows = true;

    return scene;
};
const scene = createScene();`;
        }

        function getVoxelWormholeCode() {
            return `const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);

    const camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 30, new BABYLON.Vector3(0, 0, 0), scene);
    if (camera.attachControls) {
        camera.attachControls(canvas, true);
    }

    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Add glow layer for neon effect
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.5;

    // SimplexNoise implementation for procedural generation
    class SimplexNoise {
        constructor() {
            this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
            this.p = [];
            for(let i=0; i<256; i++) { this.p[i] = Math.floor(Math.random()*256); }
            this.perm = [];
            for(let i=0; i<512; i++) { this.perm[i]=this.p[i & 255]; }
            this.F3 = 1.0/3.0;
            this.G3 = 1.0/6.0;
        }

        dot(g, x, y, z) {
            return g[0]*x + g[1]*y + g[2]*z;
        }

        noise(xin, yin, zin) {
            let n0, n1, n2, n3;
            let s = (xin+yin+zin)*this.F3;
            let i = Math.floor(xin+s);
            let j = Math.floor(yin+s);
            let k = Math.floor(zin+s);
            let t = (i+j+k)*this.G3;
            let X0 = i-t;
            let Y0 = j-t;
            let Z0 = k-t;
            let x0 = xin-X0;
            let y0 = yin-Y0;
            let z0 = zin-Z0;
            let i1, j1, k1;
            let i2, j2, k2;
            if(x0>=y0) {
                if(y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
            } else {
                if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
            }
            let x1 = x0 - i1 + this.G3;
            let y1 = y0 - j1 + this.G3;
            let z1 = z0 - k1 + this.G3;
            let x2 = x0 - i2 + 2.0*this.G3;
            let y2 = y0 - j2 + 2.0*this.G3;
            let z2 = z0 - k2 + 2.0*this.G3;
            let x3 = x0 - 1.0 + 3.0*this.G3;
            let y3 = y0 - 1.0 + 3.0*this.G3;
            let z3 = z0 - 1.0 + 3.0*this.G3;
            let ii = i & 255;
            let jj = j & 255;
            let kk = k & 255;
            let gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
            let gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
            let gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
            let gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
            let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
            if(t0<0) n0 = 0.0;
            else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0); }
            let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
            if(t1<0) n1 = 0.0;
            else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1); }
            let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
            if(t2<0) n2 = 0.0;
            else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2); }
            let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
            if(t3<0) n3 = 0.0;
            else { t3 *= t3; n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3); }
            return 32.0*(n0 + n1 + n2 + n3);
        }
    }

    const noise = new SimplexNoise();
    const voxels = [];
    const maxVoxels = 2000; // Performance limit
    let cameraZ = 0;

    // Voxel generation with culling
    function generateVoxels(zStart, zEnd) {
        for(let z = zStart; z < zEnd; z += 2) {
            const radius = 10;
            for(let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                const noiseVal = noise.noise(x * 0.1, y * 0.1, z * 0.05);

                if(noiseVal > 0.2 && voxels.length < maxVoxels) {
                    const voxel = BABYLON.MeshBuilder.CreateBox("voxel", {size: 1}, scene);
                    voxel.position = new BABYLON.Vector3(x, y, z);

                    const mat = new BABYLON.StandardMaterial("mat", scene);
                    const colorPhase = z * 0.1;
                    mat.emissiveColor = new BABYLON.Color3(
                        Math.sin(colorPhase) * 0.5 + 0.5,
                        Math.sin(colorPhase + 2) * 0.5 + 0.5,
                        Math.sin(colorPhase + 4) * 0.5 + 0.5
                    );
                    voxel.material = mat;
                    voxels.push(voxel);
                }
            }
        }
    }

    // Mario star in the center
    const star = BABYLON.MeshBuilder.CreatePolyhedron("star", {type: 1, size: 2}, scene);
    const starMat = new BABYLON.PBRMaterial("starMat", scene);
    starMat.albedoColor = new BABYLON.Color3(1, 0.9, 0.2);
    starMat.metallic = 1;
    starMat.roughness = 0.1;
    starMat.emissiveColor = new BABYLON.Color3(1, 0.9, 0);
    starMat.emissiveIntensity = 2;
    star.material = starMat;

    // Initial voxel generation
    generateVoxels(-20, 40);

    // Animation loop
    scene.registerBeforeRender(() => {
        cameraZ += 0.5;
        camera.target.z = cameraZ;

        star.rotation.y += 0.05;
        star.rotation.x += 0.03;

        // Regenerate voxels for infinite tunnel
        if(cameraZ % 20 === 0) {
            const voxelsToRemove = voxels.filter(v => v.position.z < cameraZ - 30);
            voxelsToRemove.forEach(v => {
                v.dispose();
                voxels.splice(voxels.indexOf(v), 1);
            });
            generateVoxels(cameraZ + 20, cameraZ + 40);
        }
    });

    console.log("Voxel wormhole scene created successfully");
    return scene;
};
const scene = createScene();`;
        }

        function getTronscapeDemoCode() {
            return `// Minimal Perlin-like noise for fractal terrain
function fade(t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
function lerp(a, b, t) {
    return a + (b - a) * t;
}
function random2D(i, j) {
    let seed = (i * 49632) ^ (j * 325176);
    let s = Math.sin(seed) * 43758.5453;
    return s - Math.floor(s);
}
function noise2D(x, z) {
    let xi = Math.floor(x);
    let zi = Math.floor(z);
    let xf = x - xi;
    let zf = z - zi;

    let tl = random2D(xi,   zi);
    let tr = random2D(xi+1, zi);
    let bl = random2D(xi,   zi+1);
    let br = random2D(xi+1, zi+1);

    let u = fade(xf);
    let v = fade(zf);

    let top    = lerp(tl, tr, u);
    let bottom = lerp(bl, br, u);
    return lerp(top, bottom, v);
}
function fractalNoise2D(x, z, octaves, lacunarity, gain) {
    let sum = 0.0;
    let amp = 1.0;
    let freq = 1.0;
    let norm = 0.0;

    for (let i = 0; i < octaves; i++) {
        sum += amp * noise2D(x * freq, z * freq);
        norm += amp;
        freq *= lacunarity;
        amp *= gain;
    }
    return sum / norm;
}

var url = "https://cdn.rawgit.com/BabylonJS/Extensions/master/DynamicTerrain/dist/babylon.dynamicTerrain.min.js";
var s = document.createElement("script");
s.src = url;
document.head.appendChild(s);

const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    // Set background to BLACK
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    // Camera
    const camera = new BABYLON.ArcRotateCamera("camera", 0, 1.2, 180, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    camera.fov = 1.2;
    camera.maxZ = 5000;

    // Lock zoom
    camera.lowerRadiusLimit = camera.radius;
    camera.upperRadiusLimit = camera.radius;

    // Light
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Load DynamicTerrain
    s.onload = function() {
        let mapSize = 200;
        let mapData = [];
        for (let z = 0; z <= mapSize; z++) {
            for (let x = 0; x <= mapSize; x++) {
                let worldX = x - mapSize / 2;
                let worldZ = z - mapSize / 2;
                let n = fractalNoise2D(worldX * 0.04, worldZ * 0.04, 4, 2.0, 0.5);
                let y = n * 10.0;
                mapData.push(worldX, y, worldZ);
            }
        }

        let terrainOpts = {
            mapData: mapData,
            mapSubX: mapSize,
            mapSubZ: mapSize,
            terrainSub: 60
        };
        let terrain = new BABYLON.DynamicTerrain("terrain", terrainOpts, scene);
        terrain.createUVMap();
        terrain.update(true);

        let gridMat = new BABYLON.GridMaterial("gridMaterial", scene);
        gridMat.majorUnitFrequency = 1;
        gridMat.minorUnitVisibility = 0;
        gridMat.gridRatio = 1;
        gridMat.backFaceCulling = false;
        gridMat.mainColor = new BABYLON.Color3(0, 0, 0);
        gridMat.lineColor = new BABYLON.Color3(0, 1, 1);
        terrain.mesh.material = gridMat;
        terrain.mesh.position.y = -2;

        scene.onBeforeRenderObservable.add(() => {
            terrain.mesh.position.z -= 0.2;
        });
    };

    // Bigger pink sun
    let sun = BABYLON.MeshBuilder.CreateDisc("sun", { radius: 15, tessellation: 64 }, scene);
    let sunMat = new BABYLON.StandardMaterial("sunMat", scene);
    sunMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0.6);
    sun.material = sunMat;
    sun.position.set(0, 10, -30);

    camera.position.set(-6.1, 5.69, -213.73);
    camera.setTarget(sun.position);

    // Skybox
    let skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 10000 }, scene);
    skybox.infiniteDistance = true;
    skybox.applyFog = false;

    // Warp star shader
    BABYLON.Effect.ShadersStore["warpStarVertexShader"] = \`
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 worldViewProjection;
        varying vec2 vUV;
        void main() {
            vUV = uv;
            gl_Position = worldViewProjection * vec4(position, 1.0);
        }
    \`;
    BABYLON.Effect.ShadersStore["warpStarFragmentShader"] = \`
        precision highp float;
        varying vec2 vUV;
        uniform float iTime;
        uniform vec3  starColor;
        float hash12(vec2 p) {
            float h = dot(p, vec2(127.1, 311.7));
            return fract(sin(h)*43758.5453);
        }
        void main() {
            vec2 uv = vUV * 2.0 - 1.0;
            float r = length(uv);
            float angle = atan(uv.y, uv.x);
            float warpSpeed = 1.2;
            float radial = r - iTime * warpSpeed;
            float slices = 40.0;
            float rings  = 25.0;
            float sliceIndex = floor(angle * slices);
            float ringIndex  = floor(radial * rings);
            float starChance = hash12(vec2(sliceIndex, ringIndex));
            float ringPos = fract(radial * rings);
            float starIntensity = 0.0;
            if (starChance < 0.25) {
                float bandWidth = 0.15;
                if (ringPos < bandWidth) {
                    float fade = 1.0 - (ringPos / bandWidth);
                    starIntensity = fade;
                }
            }
            float centerGlow = max(0.0, 0.15 - r) * 4.0;
            starIntensity = max(starIntensity, centerGlow);
            vec3 col = mix(vec3(0.0), starColor, starIntensity);
            gl_FragColor = vec4(col, 1.0);
        }
    \`;
    let warpStarMat = new BABYLON.ShaderMaterial(
        "warpStarMat",
        scene,
        { vertex: "warpStar", fragment: "warpStar" },
        {
            attributes: ["position", "uv"],
            uniforms: ["worldViewProjection", "iTime", "starColor"]
        }
    );
    warpStarMat.setColor3("starColor", new BABYLON.Color3(0.9, 0.9, 1.0));
    let startTime = Date.now();
    scene.onBeforeRenderObservable.add(() => {
        let t = (Date.now() - startTime) * 0.001;
        warpStarMat.setFloat("iTime", t);
    });
    skybox.material = warpStarMat;

    // Fog
    scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
    scene.fogStart = 300;
    scene.fogEnd = 900;
    scene.fogColor = new BABYLON.Color3(0,0,0);

    // Postprocess pipeline
    let pipeline = new BABYLON.DefaultRenderingPipeline("DefaultPipeline", true, scene, [camera]);
    pipeline.bloomEnabled = true;
    pipeline.bloomThreshold = 0.2;
    pipeline.bloomWeight = 1.0;
    pipeline.bloomKernel = 64;
    pipeline.bloomScale = 0.5;
    pipeline.chromaticAberrationEnabled = true;
    pipeline.chromaticAberration.aberrationAmount = 4.0;
    pipeline.chromaticAberration.radialIntensity = 1.0;

    console.log("Tronscape scene created successfully");
    return scene;
};
const scene = createScene();`;
        }

        function getFractalInvaderCode() {
            return `const createScene = function () {
    const scene = new BABYLON.Scene(engine);

    // Camera setup
    const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 3.6, -21), scene);
    camera.setTarget(new BABYLON.Vector3(0, 3.6, 0));

    // Light setup
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // VoxelVader function - generates procedural space invader
    function VoxelVader({
        colorPool = [0xff004b, 0x0000ff, 0x00ff3c, 0x6900ff, 0xff0000, 0x00b3ff, 0x1e00ff],
        color = [
            BABYLON.Color3.FromHexString("#" + colorPool[Math.floor(Math.random() * colorPool.length)].toString(16).padStart(6, '0')),
            BABYLON.Color3.FromHexString("#" + colorPool[Math.floor(Math.random() * colorPool.length)].toString(16).padStart(6, '0'))
        ],
        size = 5,
        steps = size / 5,
        padding = parseInt(size / 2),
        position = [0, 0, 0]
    }) {
        let groups = [];

        // Create materials with emissive glow
        let materials = [
            new BABYLON.StandardMaterial("material1", scene),
            new BABYLON.StandardMaterial("material2", scene)
        ];

        materials[0].diffuseColor = color[0];
        materials[0].specularColor = new BABYLON.Color3(1, 1, 0);
        materials[0].emissiveColor = color[0].scale(0.5);
        materials[0].emissiveIntensity = 0.7;

        materials[1].diffuseColor = color[1];
        materials[1].emissiveColor = color[1].scale(0.5);
        materials[1].emissiveIntensity = 0.7;

        const voxelMesh = generateVoxel({ colorPool, color, size, steps, padding, materials, camera, scene, groups });

        // Animate glow intensity
        let time = 0;
        scene.registerBeforeRender(() => {
            time += 0.05;
            gl.intensity = 0.5 + Math.sin(time) * 0.25;

            if (groups.length) {
                for (let i = 0; i < groups.length; i++) {
                    if (groups[i].isGlowing) {
                        groups[i].material.emissiveIntensity = 0.7 + Math.sin(time) * 0.3;
                    }
                }
            }
        });

        return voxelMesh;
    }

    // Generate voxel mesh with symmetric pattern
    const generateVoxel = ({ colorPool, color, size, steps, padding, materials, camera, scene, groups }) => {
        const createVaderMesh = (material) => {
            let mesh = BABYLON.MeshBuilder.CreateBox("box", {}, scene);
            mesh.material = material.clone("clonedMaterial");
            return mesh;
        }

        const VaderMesh = (obj = {}) => {
            obj.vaderObj = new BABYLON.Mesh("VaderObj", scene);
            obj.bg = new BABYLON.Mesh("VaderObj2BG", scene);
            let col = [];

            // Generate symmetric pattern
            for (let j = 0; j < size; j += steps) {
                let m = 1;
                col[j] = [];
                for (let i = 0; i < size / 2; i += steps) {
                    let c = Math.random() > 0.5;
                    col[j][i] = c;
                    col[j][i + (size - steps) / m] = c;
                    m++;
                }
            }

            // Create voxel grid
            for (let j = 0; j < size; j += steps) {
                for (let i = 0; i < size; i += steps) {
                    let vaders = createVaderMesh(materials[0]);
                    let vader2 = createVaderMesh(materials[0]);
                    let vadersBG = createVaderMesh(materials[1]);
                    vadersBG.position = new BABYLON.Vector3(i, j, 4);
                    vadersBG.isVisible = col[j][i];
                    vadersBG.vaderT = 'bg';
                    vaders.position = new BABYLON.Vector3(i, j, 5);
                    vaders.isVisible = col[j][i];
                    vaders.vaderT = 'front';
                    vader2.vaderT = 'front';
                    vader2.position = new BABYLON.Vector3(i, j, 6);
                    vader2.isVisible = col[j][i];
                    obj.bg.addChild(vadersBG);
                    obj.vaderObj.addChild(vadersBG);
                    obj.vaderObj.addChild(vaders);
                    obj.vaderObj.addChild(vader2);
                }
            }
            return obj.vaderObj;
        }

        let voxelInvader = VaderMesh();

        // Merge geometry for performance
        let visibileArrBG = [];
        let visibileArr = [];
        let meshInvaderVisibile = (obj) => {
            for (let i = 0; i < obj.getChildren().length; i++) {
                let child = obj.getChildren()[i];
                if (child.getChildren().length === 0 && child.isVisible && child.vaderT === 'bg') {
                    visibileArrBG.push(child);
                } else if (child.isVisible && child.vaderT === 'front') {
                    visibileArr.push(child);
                } else {
                    meshInvaderVisibile(child);
                }
            }
        }
        meshInvaderVisibile(voxelInvader);

        var mergedGeo = BABYLON.Mesh.MergeMeshes(visibileArr, true, true, undefined, false, true);
        var mergedGeoBG = BABYLON.Mesh.MergeMeshes(visibileArrBG, true, true, undefined, false, true);

        if (mergedGeo) {
            mergedGeo.material = materials[0].clone("mergedMaterial1");
            groups.push(mergedGeo);
            groups[groups.length - 1].isGlowing = false;

            let glowingMeshFront = mergedGeo.clone("glowingMeshFront");
            glowingMeshFront.scaling.multiplyInPlace(new BABYLON.Vector3(1.1, 1.1, 1.1));
            glowingMeshFront.material = materials[0].clone("glowingMaterial1");
            glowingMeshFront.material.emissiveColor = color[0];
            glowingMeshFront.material.emissiveIntensity = 1;
            glowingMeshFront.isGlowing = true;
            groups.push(glowingMeshFront);
        }

        if (mergedGeoBG) {
            mergedGeoBG.material = materials[1].clone("mergedMaterial2");
            groups.push(mergedGeoBG);
            groups[groups.length - 1].isGlowing = false;

            let glowingMesh = mergedGeoBG.clone("glowingMesh");
            glowingMesh.scaling.multiplyInPlace(new BABYLON.Vector3(1.1, 1.1, 1.1));
            glowingMesh.material = materials[1].clone("glowingMaterial2");
            glowingMesh.material.emissiveColor = color[1];
            glowingMesh.material.emissiveIntensity = 1;
            glowingMesh.isGlowing = true;
            groups.push(glowingMesh);
        }

        for (let i = 0; i < groups.length; i++) {
            voxelInvader.addChild(groups[i]);
        }

        return voxelInvader;
    }

    function randomSize(minSize, maxSize) {
        return Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
    }

    function spawnVoxelVader(scene, camera) {
        const vxSize = randomSize(2, 6);
        const voxelVader = VoxelVader({
            size: vxSize,
            steps: vxSize / 5,
            padding: 1,
            position: [0, 0, 0]
        });

        // Spawn in front of camera
        const spawnDistance = 50;
        const direction = camera.getForwardRay().direction;
        const spawnPosition = camera.position.add(direction.scale(spawnDistance));
        voxelVader.position = spawnPosition;
        voxelVader.position.y = 3;

        const scale = 0.5;
        voxelVader.scaling = new BABYLON.Vector3(scale, scale, scale);
        voxelVader.rotation.y = Math.PI / 4;
        voxelVader.lookAt(camera.position);

        // Random transparency
        const transparency = Math.random() * 0.5 + 0.5;
        voxelVader.getChildMeshes().forEach(mesh => {
            if (mesh.material) {
                mesh.material.alpha = transparency;
            }
        });

        return voxelVader;
    }

    const voxelVaders = [];
    const maxVoxelVaders = 1;

    function moveVoxelVaders(camera) {
        const speed = 0.3;
        voxelVaders.forEach((vader, index) => {
            const direction = camera.position.subtract(vader.position).normalize();
            vader.position.addInPlace(direction.scale(speed));
            vader.lookAt(camera.position);

            // Remove if too close
            if (BABYLON.Vector3.Distance(vader.position, camera.position) < 2) {
                vader.dispose();
                voxelVaders.splice(index, 1);
            }
        });
    }

    for (let i = 0; i < maxVoxelVaders; i++) {
        voxelVaders.push(spawnVoxelVader(scene, camera));
    }

    const skyBoxImgs = [
        "https://raw.githubusercontent.com/seacloud9/seacloud9.github.io/master/assets/sky/sky",
        "https://raw.githubusercontent.com/seacloud9/seacloud9.github.io/master/assets/aquatic/sky"
    ];

    function getRandomSkyBoxImg() {
        const randomIndex = Math.floor(Math.random() * skyBoxImgs.length);
        return skyBoxImgs[randomIndex];
    }

    // Skybox
    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 10000.0}, scene);
    const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(getRandomSkyBoxImg(), scene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMaterial;

    // Water plane with reflections
    const waterMesh = BABYLON.MeshBuilder.CreateGround("waterMesh", {width: 200, height: 200}, scene);

    // Load WaterMaterial extension
    const script = document.createElement('script');
    script.src = 'https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js';
    script.onload = () => {
        console.log('WaterMaterial library loaded');
        const waterMaterial = new BABYLON.WaterMaterial("water", scene);
        waterMaterial.bumpTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/waterbump.png", scene);
        waterMaterial.windForce = 45;
        waterMaterial.waveHeight = 0.4;
        waterMaterial.bumpHeight = 2.3;
        waterMaterial.windDirection = new BABYLON.Vector2(-1, 0);
        waterMaterial.waterColor = new BABYLON.Color3(0.1, 0.1, 0.6);
        waterMaterial.colorBlendFactor = 0.0;
        waterMaterial.waveLength = 0.05;
        waterMaterial.addToRenderList(skybox);
        waterMesh.material = waterMaterial;

        // Add shapes to water reflection list
        triangles.forEach(triangle => waterMaterial.addToRenderList(triangle));
        squares.forEach(square => waterMaterial.addToRenderList(square));
    };
    document.head.appendChild(script);

    // Glowing materials
    const glowMaterial = new BABYLON.StandardMaterial("glowMaterial", scene);
    glowMaterial.emissiveColor = new BABYLON.Color3(0, 1, 1);
    glowMaterial.disableLighting = true;

    const redGlowMaterial = new BABYLON.StandardMaterial("redGlowMaterial", scene);
    redGlowMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0);
    redGlowMaterial.disableLighting = true;

    // Create hollow triangle mesh
    const createHollowTriangle = (size) => {
        const trianglePoints = [
            new BABYLON.Vector3(-size, -size * Math.sqrt(3) / 2, 0),
            new BABYLON.Vector3(size, -size * Math.sqrt(3) / 2, 0),
            new BABYLON.Vector3(0, size * Math.sqrt(3) / 2, 0)
        ];
        const lines = BABYLON.MeshBuilder.CreateLines("hollowTriangle", {points: [...trianglePoints, trianglePoints[0]]}, scene);
        return lines;
    };

    // Create hollow square mesh
    const createHollowSquare = (size) => {
        const squarePoints = [
            new BABYLON.Vector3(-size, -size, 0),
            new BABYLON.Vector3(size, -size, 0),
            new BABYLON.Vector3(size, size, 0),
            new BABYLON.Vector3(-size, size, 0)
        ];
        const lines = BABYLON.MeshBuilder.CreateLines("hollowSquare", {points: [...squarePoints, squarePoints[0]]}, scene);
        return lines;
    };

    // Create animated geometric shapes
    const triangles = [];
    const squares = [];
    const shapeCount = 30;
    const spacing = 10;
    const startZ = -5;
    const squareOffset = 0;

    for (let i = 0; i < shapeCount; i++) {
        const triangle = createHollowTriangle(0.5);
        triangle.material = glowMaterial;
        triangle.position = new BABYLON.Vector3(0, 4, startZ + i * spacing);
        triangles.push(triangle);

        const square = createHollowSquare(0.5);
        square.material = redGlowMaterial;
        square.position = new BABYLON.Vector3(squareOffset, 4, startZ + i * spacing);
        square.rotation.z = Math.PI / 4;
        squares.push(square);
    }

    // Glow layer
    const gl = new BABYLON.GlowLayer("glow", scene);
    gl.intensity = 1.25;

    // Animation
    const speed = 0.1;
    scene.registerBeforeRender(() => {
        moveVoxelVaders(camera);

        while (voxelVaders.length < maxVoxelVaders) {
            voxelVaders.push(spawnVoxelVader(scene, camera));
        }

        triangles.forEach((triangle, index) => {
            triangle.position.z -= speed;
            if (triangle.position.z < -15) {
                triangle.position.z = startZ;
            }
            triangle.lookAt(camera.position);

            const square = squares[index];
            square.position.z = triangle.position.z;
            if (square.position.z < -15) {
                square.position.z = startZ;
            }
            square.rotation.y = Math.atan2(camera.position.x - square.position.x, camera.position.z - square.position.z);
        });
    });

    console.log("Fractal Invader scene created successfully");
    return scene;
};
const scene = createScene();`;
        }

        function getSpaceHarrierCode() {
            return `// Simplified Space Harrier - Full version: https://playground.babylonjs.com/#WJ20GP#16
const createScene = function() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);

    let score = 0;
    let gameOver = false;
    const enemies = [];
    const projectiles = [];

    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    const player = BABYLON.MeshBuilder.CreateSphere("player", {diameter: 2}, scene);
    player.position = new BABYLON.Vector3(0, 5, 0);
    const playerMat = new BABYLON.StandardMaterial("playerMat", scene);
    playerMat.emissiveColor = new BABYLON.Color3(0, 0.7, 1);
    player.material = playerMat;

    const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 10, -15), scene);
    camera.lockedTarget = player;
    camera.radius = 15;
    camera.heightOffset = 5;
    scene.activeCamera = camera;

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 1000, height: 1000}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.2, 0.4);
    ground.material = groundMat;

    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000}, scene);
    const skyboxMat = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMat.backFaceCulling = false;
    skyboxMat.reflectionTexture = new BABYLON.CubeTexture("https://assets.babylonjs.com/textures/skybox", scene);
    skyboxMat.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMat.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMat;

    const keys = {w: false, a: false, s: false, d: false, space: false,
                  arrowUp: false, arrowDown: false, arrowLeft: false, arrowRight: false};

    scene.onKeyboardObservable.add((kbInfo) => {
        const key = kbInfo.event.key.toLowerCase();
        const isDown = kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN;

        if (key === "arrowup") keys.arrowUp = isDown;
        else if (key === "arrowdown") keys.arrowDown = isDown;
        else if (key === "arrowleft") keys.arrowLeft = isDown;
        else if (key === "arrowright") keys.arrowRight = isDown;
        else if (key === " ") keys.space = isDown;
        else if (key in keys) keys[key] = isDown;
    });

    const createEnemy = () => {
        const enemy = BABYLON.MeshBuilder.CreateBox("enemy", {size: 2}, scene);
        const enemyMat = new BABYLON.StandardMaterial("enemyMat", scene);
        const colors = ["#ff004b", "#0000ff", "#00ff3c", "#ff0000", "#00b3ff"];
        enemyMat.emissiveColor = BABYLON.Color3.FromHexString(colors[Math.floor(Math.random() * colors.length)]);
        enemy.material = enemyMat;
        enemy.position = new BABYLON.Vector3(
            Math.random() * 60 - 30,
            Math.random() * 10 + 2,
            player.position.z + 200
        );
        enemy.health = 100;
        enemies.push(enemy);
        return enemy;
    };

    let lastFireTime = 0;
    const fireProjectile = () => {
        if (gameOver) return;
        const now = performance.now() / 1000;
        if (now - lastFireTime < 0.2) return;
        lastFireTime = now;

        const projectile = BABYLON.MeshBuilder.CreateSphere("projectile", {diameter: 0.5}, scene);
        const projMat = new BABYLON.StandardMaterial("projMat", scene);
        projMat.emissiveColor = new BABYLON.Color3(0, 1, 0.5);
        projectile.material = projMat;
        projectile.position = player.position.clone();
        projectile.position.z += 2;
        projectile.speed = 3;
        projectile.damage = 50;
        projectiles.push(projectile);
    };

    scene.registerBeforeRender(() => {
        if (gameOver) return;

        const speed = 0.3;
        if (keys.w || keys.arrowUp) player.position.y += speed;
        if (keys.s || keys.arrowDown) player.position.y -= speed;
        if (keys.a || keys.arrowLeft) player.position.x -= speed;
        if (keys.d || keys.arrowRight) player.position.x += speed;

        player.position.y = Math.max(2, Math.min(20, player.position.y));
        player.position.x = Math.max(-40, Math.min(40, player.position.x));

        if (keys.space) fireProjectile();

        projectiles.forEach((proj, i) => {
            proj.position.z += proj.speed;
            if (proj.position.z > player.position.z + 300) {
                proj.dispose();
                projectiles.splice(i, 1);
            }
        });

        enemies.forEach((enemy, i) => {
            enemy.position.z -= 0.5;
            enemy.rotation.y += 0.02;
            if (enemy.position.z < player.position.z - 50) {
                enemy.dispose();
                enemies.splice(i, 1);
            }
        });

        if (enemies.length < 10 && Math.random() < 0.02) createEnemy();

        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i];
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                if (BABYLON.Vector3.Distance(proj.position, enemy.position) < 2) {
                    enemy.health -= proj.damage;
                    proj.dispose();
                    projectiles.splice(i, 1);
                    if (enemy.health <= 0) {
                        enemy.dispose();
                        enemies.splice(j, 1);
                        score += 100;
                    }
                    break;
                }
            }
        }

        for (let i = 0; i < enemies.length; i++) {
            if (BABYLON.Vector3.Distance(player.position, enemies[i].position) < 3) {
                gameOver = true;
                player.isVisible = false;
                console.log("GAME OVER! Final Score: " + score);
                break;
            }
        }
    });

    const ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    const scoreText = new BABYLON.GUI.TextBlock();
    scoreText.text = "Score: 0";
    scoreText.color = "white";
    scoreText.fontSize = 24;
    scoreText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
    scoreText.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
    scoreText.left = "10px";
    scoreText.top = "10px";
    ui.addControl(scoreText);

    const controlsText = new BABYLON.GUI.TextBlock();
    controlsText.text = "WASD/Arrows: Move | SPACE: Fire";
    controlsText.color = "cyan";
    controlsText.fontSize = 18;
    controlsText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    controlsText.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    controlsText.top = "-10px";
    ui.addControl(controlsText);

    scene.registerBeforeRender(() => {
        scoreText.text = "Score: " + score + (gameOver ? " - GAME OVER" : "");
    });

    console.log("🎮 Space Harrier Game Started!");
    console.log("Full version: https://playground.babylonjs.com/#WJ20GP#16");
    return scene;
};
const scene = createScene();`;
        }

        // MARK: - Testing and Debugging Functions
        
        /// Test injection system - can be called from browser console
        function testInjection() {
            console.log('🧪 Testing injection system from playground...');
            notifySwift('testInjection', {});
        }
        
        /// Check editor readiness - can be called from browser console  
        function checkEditorReadiness() {
            const monacoReady = window.editor && 
                               typeof window.editor.setValue === 'function' && 
                               typeof window.editor.getValue === 'function' &&
                               typeof window.editor.layout === 'function';
            
            const editorFlagReady = window.editorReady === true;
            const domReady = document.readyState === 'complete';
            const injectionFuncReady = typeof window.setFullEditorContent === 'function';
            
            const result = {
                monaco: monacoReady,
                flag: editorFlagReady, 
                dom: domReady,
                injection: injectionFuncReady,
                ready: monacoReady && editorFlagReady && domReady
            };
            
            console.log('🧪 Editor readiness check:', result);
            return result;
        }
        
        // Make test functions globally available
        window.testInjection = testInjection;
        window.checkEditorReadiness = checkEditorReadiness;
        
        console.log('🧪 Test functions available: testInjection(), checkEditorReadiness()');
    </script>
</body>
</html>
