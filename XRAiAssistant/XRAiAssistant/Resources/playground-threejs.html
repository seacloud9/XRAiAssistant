<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Playground</title>
    
    <!-- Import Map for Three.js ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/super-three@0.173.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/super-three@0.173.0/examples/jsm/"
        }
    }
    </script>

    <!-- Three.js Core (super-three v0.173.0 from CDN) - Load as ES module -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // Make THREE and addons globally available
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;
        window.EffectComposer = EffectComposer;
        window.RenderPass = RenderPass;
        window.UnrealBloomPass = UnrealBloomPass;
        window.OutputPass = OutputPass;

        console.log('✅ super-three v0.173.0 loaded from CDN, version:', THREE.REVISION);
        console.log('✅ OrbitControls available:', typeof OrbitControls !== 'undefined');
        console.log('✅ Postprocessing addons available');

        // Dispatch event to signal Three.js is ready
        window.dispatchEvent(new CustomEvent('threejs-loaded'));
    </script>


    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js" onerror="console.error('❌ Failed to load Monaco loader')"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #1177bb;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .editor-container {
            width: 0%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease-in-out;
        }

        .editor-container.open {
            width: 100%;
        }

        .canvas-container {
            width: 100%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.3s ease-in-out;
        }

        .canvas-container.editor-open {
            width: 0%;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
        }
        
        .editor-toggle-btn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: #007acc;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 12px 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            z-index: 20;
            transition: all 0.3s ease-in-out;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .editor-toggle-btn:hover {
            background: #1177bb;
        }

        .editor-toggle-btn:active {
            background: #0e639c;
        }

        /* When editor is open, button moves to right edge */
        .editor-toggle-btn.editor-open {
            left: auto;
            right: 0;
            border-radius: 4px 0 0 4px;
        }
        
        .footer {
            background: #007acc;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        /* Floating Console Window */
        .console-window {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            background: #1e1e1e;
            border: 1px solid #007acc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            z-index: 2000;
            resize: both;
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            max-width: 90vw;
            max-height: 80vh;
        }

        .console-window.minimized {
            height: auto !important;
            min-height: auto;
            resize: none;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        .console-window.hidden {
            display: none;
        }

        .console-title-bar {
            background: #007acc;
            color: white;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .console-title {
            flex: 1;
        }

        .console-controls {
            display: flex;
            gap: 8px;
        }

        .console-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .console-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .console-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #ccc;
            background: #1e1e1e;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }

        .console-window.minimized .console-content {
            display: none;
        }

        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
            white-space: pre-wrap;
            user-select: text;
            -webkit-user-select: text;
        }

        .console-error {
            color: #f14c4c;
        }

        .console-warning {
            color: #ffcc02;
        }

        .console-log {
            color: #ccc;
        }

        .console-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #007acc 50%);
            opacity: 0.5;
        }

        .console-window.minimized .console-resize-handle {
            display: none;
        }

        /* Console Open Button (always visible in editor) */
        .console-open-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .console-open-btn:hover {
            background: #1177bb;
            transform: scale(1.1);
        }

        .console-open-btn:active {
            background: #0e639c;
            transform: scale(0.95);
        }

        .console-open-btn.hidden {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        /* Remove media query - same behavior across all devices per requirements */
        /* The editor starts hidden (width: 0%) on all screen sizes */
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">▶ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">🗑 Clear</button>
        <button class="menu-btn" onclick="saveScene()">💾 Save</button>
        <button class="menu-btn" onclick="downloadScene()">⬇ Download</button>
        <button class="menu-btn" onclick="newScene()">📄 New</button>
        <button class="menu-btn" onclick="openDocumentation()">📖 Documentation</button>
        <button class="menu-btn" onclick="toggleConsole()">🖥 Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Select Example...</option>
            <option value="basic-scene">Basic Scene</option>
            <option value="rotating-cube">Galaxy Cubes ✨</option>
            <option value="lighting">Orbiting Lights 💡</option>
            <option value="materials">Materials Demo</option>
            <option value="rainbow">Rainbow Arc 🌈</option>
            <option value="postprocessing">Bloom Effect ✨</option>
        </select>
    </div>
    
    <div class="main-container">
        <div class="editor-container" id="editorContainer">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <button class="console-open-btn" id="consoleOpenBtn" title="Open Console">📟</button>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <button class="editor-toggle-btn" id="editorToggleBtn" onclick="toggleEditor()">CODE</button>
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Three.js...</div>
        </div>
    </div>

    <div class="footer">
        Three.js Playground - Powered by WebGL
    </div>

    <div class="error-display" id="errorDisplay"></div>

    <!-- Floating Console Window -->
    <div class="console-window" id="consoleWindow">
        <div class="console-title-bar" id="consoleTitleBar">
            <div class="console-title">Console</div>
            <div class="console-controls">
                <button class="console-btn" id="consoleMinimizeBtn" title="Minimize">−</button>
                <button class="console-btn" id="consoleToggleBtn" title="Expand">↕</button>
                <button class="console-btn" id="consoleCloseBtn" title="Close">×</button>
            </div>
        </div>
        <div class="console-content" id="consoleContent"></div>
        <div class="console-resize-handle" id="consoleResizeHandle"></div>
    </div>

    <script>
        // IMMEDIATE LOGGING TO DEBUG THREE.JS TEMPLATE LOADING
        console.log('🚀 THREE.JS TEMPLATE SCRIPT STARTING...');
        console.log('🔍 Three.js availability:', typeof THREE !== 'undefined');
        console.log('🔍 Monaco availability:', typeof monaco !== 'undefined');
        console.log('🔍 Document state:', document.readyState);
        console.log('🔍 Window loaded:', document.readyState === 'complete');
        
        let editor;
        let renderer;
        let scene;
        let camera;
        let controls;
        let canvas;
        let animationId;
        let isResizing = false;
        let consoleMessages = [];
        let isEditorOpen = false;
        let consoleState = {
            x: null,
            y: null,
            width: 400,
            height: 300,
            minimized: false,
            hidden: false
        };

        // Editor toggle functionality - switches between code view (100%) and scene view (100%)
        function toggleEditor() {
            isEditorOpen = !isEditorOpen;
            const editorContainer = document.getElementById('editorContainer');
            const canvasContainer = document.getElementById('canvasContainer');
            const toggleBtn = document.getElementById('editorToggleBtn');

            if (isEditorOpen) {
                // Show code editor (100%), hide scene (0%)
                editorContainer.classList.add('open');
                canvasContainer.classList.add('editor-open');
                toggleBtn.classList.add('editor-open');
                toggleBtn.textContent = 'SCENE';

                // Trigger Monaco layout after transition completes
                setTimeout(() => {
                    if (editor && typeof editor.layout === 'function') {
                        editor.layout();
                    }
                }, 300);
            } else {
                // Show scene (100%), hide code editor (0%)
                editorContainer.classList.remove('open');
                canvasContainer.classList.remove('editor-open');
                toggleBtn.classList.remove('editor-open');
                toggleBtn.textContent = 'CODE';
            }

            // Resize canvas and renderer
            if (renderer && camera) {
                setTimeout(() => {
                    const canvas = document.getElementById('renderCanvas');
                    if (canvas) {
                        camera.aspect = canvas.clientWidth / canvas.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                    }
                }, 350);
            }
        }
        
        console.log('✅ Three.js template variables initialized');
        
        // Console management functions (must be defined before console overrides)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function updateConsoleDisplay() {
            const consoleContent = document.getElementById('consoleContent');
            if (consoleContent && consoleMessages.length > 0) {
                consoleContent.innerHTML = consoleMessages.map(msg =>
                    `<div class="console-message console-${msg.type}">${escapeHtml(msg.message)}</div>`
                ).join('');
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50);
            }
            updateConsoleDisplay();
        }
        
        // Define critical injection functions BEFORE Monaco initialization
        function setFullEditorContent(codeString) {
            console.log('🎯 Three.js setFullEditorContent called with code length:', codeString.length);
            console.log('🔍 Three.js editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy for Three.js
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('📝 Three.js Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('✅ Three.js Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('⚠️ Three.js Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('📝 Three.js Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('✅ Three.js Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('📝 Three.js Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('✅ Three.js Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('❌ Three.js Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`🎉 Three.js content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('🚀 Auto-running the injected Three.js code...');
                                runCode();
                                
                                // Force immediate render after code injection
                                if (scene && camera && renderer) {
                                    renderer.render(scene, camera);
                                    console.log('🎯 Forced immediate render after code injection');
                                }
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true,
                                library: 'threejs'
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`❌ Three.js Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('❌ All Three.js injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All Three.js injection strategies failed',
                    library: 'threejs'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
            // Auto-show console for critical errors
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay) {
                consoleDisplay.style.display = 'block';
            }
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
            // Auto-show console for warnings
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay) {
                consoleDisplay.style.display = 'block';
            }
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Global error handler to catch uncaught errors
        window.addEventListener('error', function(event) {
            console.error('❌ UNCAUGHT ERROR:', event.error);
            console.error('❌ Error message:', event.message);
            console.error('❌ Error source:', event.filename + ':' + event.lineno);
            if (event.error && event.error.stack) {
                console.error('❌ Stack trace:', event.error.stack);
            }
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('❌ UNHANDLED PROMISE REJECTION:', event.reason);
        });

        // Initialize Monaco Editor with enhanced error handling and fallback
        console.log('Starting Monaco Editor initialization...');
        
        // Set longer timeout for CDN loading
        let monacoTimeout = setTimeout(() => {
            console.error('❌ Monaco Editor CDN loading timeout - creating fallback editor');
            createFallbackEditor();
        }, 10000); // 10 second timeout
        
        require.config({ 
            paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' },
            waitSeconds: 30 // Increase wait time for CDN
        });
        
        require(['vs/editor/editor.main'], function () {
            clearTimeout(monacoTimeout); // Cancel timeout since loading succeeded
            console.log('✅ Monaco modules loaded successfully, creating editor...');
            
            try {
                const editorContainer = document.getElementById('monaco-editor');
                if (!editorContainer) {
                    throw new Error('Monaco editor container not found');
                }
                
                editor = monaco.editor.create(editorContainer, {
                    value: getDefaultCode(),
                    language: 'javascript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('✅ Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible with multiple references
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                        // Simple readiness check - simplified to match working Babylon.js exactly
                if (editor && editor.getModel && typeof editor.setValue === 'function') {
                    // Mark as ready immediately like Babylon.js does
                    window.editorReady = true;
                    console.log('✅ Monaco editor ready for injection');
                    
                    // Initialize Three.js after Monaco is confirmed ready
                    initializeThreeJS();
                } else {
                    console.error('❌ Monaco editor creation failed');
                    createFallbackEditor();
                }
                
                
            } catch (editorError) {
                console.error('❌ Failed to create Monaco editor:', editorError);
                createFallbackEditor();
            }
        }, function(error) {
            clearTimeout(monacoTimeout);
            console.error('❌ Failed to load Monaco from CDN:', error);
            createFallbackEditor();
        });
        
        // Fallback editor function
        function createFallbackEditor() {
            console.log('🔧 Creating fallback textarea editor...');
            
            const editorContainer = document.getElementById('monaco-editor');
            if (!editorContainer) {
                console.error('❌ Editor container not found');
                return;
            }
            
            // Create a textarea fallback
            editorContainer.innerHTML = '<textarea id="fallback-editor" style="width: 100%; height: 100%; background: #1e1e1e; color: #fff; font-family: \'Monaco\', \'Consolas\', monospace; font-size: 14px; border: none; outline: none; padding: 10px;"></textarea>';
            
            const textarea = document.getElementById('fallback-editor');
            if (textarea) {
                textarea.value = getDefaultCode();
                
                // Create minimal editor interface
                window.editor = {
                    setValue: (code) => { textarea.value = code; },
                    getValue: () => textarea.value,
                    getModel: () => ({ setValue: (code) => textarea.value = code }),
                    layout: () => {},
                    focus: () => textarea.focus(),
                    setPosition: () => {},
                    onDidChangeModelContent: (callback) => {
                        textarea.addEventListener('input', callback);
                        return { dispose: () => {} };
                    }
                };
                
                window.monacoEditor = window.editor;
                window.codeEditor = window.editor;
                
                // Auto-save on changes
                textarea.addEventListener('input', () => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Mark as ready
                window.editorReady = true;
                console.log('✅ Fallback editor ready for injection');
                
                // Initialize Three.js
                initializeThreeJS();
            }
        }
        
        // Initialize Three.js with comprehensive error handling
        function initializeThreeJS() {
            console.log('🚀 Initializing Three.js...');

            // Check if THREE is available, if not wait for it
            if (typeof THREE === 'undefined') {
                console.log('⏳ Waiting for Three.js module to load...');
                window.addEventListener('threejs-loaded', function() {
                    console.log('✅ Three.js module loaded event received');
                    initializeThreeJSCore();
                }, { once: true });
                return;
            }

            initializeThreeJSCore();
        }

        function initializeThreeJSCore() {
            console.log('🚀 Starting Three.js core initialization...');

            try {
                // Verify THREE is available
                if (typeof THREE === 'undefined') {
                    console.error('❌ CRITICAL: THREE.js library not loaded from CDN');
                    throw new Error('THREE.js library not loaded - check network connection');
                }
                
                canvas = document.getElementById('renderCanvas');
                if (!canvas) {
                    console.error('❌ CRITICAL: Canvas element not found in DOM');
                    throw new Error('Canvas element not found');
                }
                
                console.log('✅ Canvas found:', canvas.clientWidth + 'x' + canvas.clientHeight);
                console.log('✅ THREE.js version available:', THREE.REVISION);
                
                // Create renderer with error handling
                console.log('🎨 Creating WebGL renderer...');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    preserveDrawingBuffer: true
                });
                
                const canvasWidth = canvas.clientWidth || 800;
                const canvasHeight = canvas.clientHeight || 600;
                renderer.setSize(canvasWidth, canvasHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                console.log('✅ Three.js renderer created successfully:', canvasWidth + 'x' + canvasHeight);
                
                // Test renderer capabilities
                const gl = renderer.getContext();
                if (!gl) {
                    console.error('❌ CRITICAL: WebGL context not available');
                    throw new Error('WebGL not supported');
                }
                console.log('✅ WebGL context created successfully');
                
            } catch (rendererError) {
                console.error('❌ CRITICAL: Three.js renderer creation failed:', rendererError);
                console.error('❌ Error stack:', rendererError.stack);
                return; // Don't continue if renderer fails
            }
            
            try {
                // Create default scene and camera
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, (canvas.clientWidth || 800) / (canvas.clientHeight || 600), 0.1, 1000);
                console.log('✅ Scene and camera created');
            } catch (sceneError) {
                console.error('❌ Scene/camera creation failed:', sceneError);
                return;
            }
            
            // Set up camera position and create OrbitControls
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Create real OrbitControls if available, otherwise use mock
            if (typeof OrbitControls !== 'undefined') {
                try {
                    controls = new OrbitControls(camera, canvas);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.target.set(0, 0, 0);
                    controls.update();
                    console.log('✅ Camera positioned with OrbitControls');
                } catch (controlsError) {
                    console.warn('⚠️ OrbitControls creation failed, using mock controls:', controlsError);
                    createMockControls();
                }
            } else {
                console.warn('⚠️ OrbitControls not available, using mock controls');
                createMockControls();
            }

            function createMockControls() {
                controls = {
                    target: { x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; } },
                    update: function() {},
                    enableDamping: false,
                    dampingFactor: 0.05
                };
            }
            
            // Make globals available
            window.canvas = canvas;
            window.renderer = renderer;
            window.scene = scene;
            window.camera = camera;
            window.controls = controls;
            window.THREE = THREE;
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start render loop BEFORE creating default scene
            startRenderLoop();
            
            // Create default scene AND run it automatically
            console.log('🎯 Auto-running default scene on initialization...');
            createDefaultScene();
            
            console.log('Three.js initialization complete');
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Three.js playground fully initialized');
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!renderer 
                });
            }, 1500);
        }
        
        function startRenderLoop() {
            console.log('🎬 Starting Three.js render loop...');
            let frameCount = 0;

            function animate() {
                animationId = requestAnimationFrame(animate);
                frameCount++;

                // Debug every 60 frames (about once per second at 60fps)
                if (frameCount % 60 === 0) {
                    console.log('🎬 Render loop active, frame:', frameCount, 'scene children:', scene?.children?.length || 0);
                }

                controls.update();

                // Execute any scene animations
                if (scene && scene.userData && scene.userData.animate) {
                    scene.userData.animate();
                }

                if (scene && camera && renderer) {
                    // Check if scene has a custom composer (for postprocessing)
                    if (scene.userData && scene.userData.composer) {
                        scene.userData.composer.render();
                    } else {
                        renderer.render(scene, camera);
                    }
                } else if (frameCount < 10) {
                    console.log('⚠️ Missing components - scene:', !!scene, 'camera:', !!camera, 'renderer:', !!renderer);
                }
            }
            animate();
        }
        
        function onWindowResize() {
            if (camera && renderer && canvas) {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }
        
        function getDefaultCode() {
            return `// Welcome to Three.js Playground!
// Create your 3D scene using Three.js r160+

const createScene = () => {
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x606060); // Even lighter background for better visibility
    
    // Create camera (use canvas dimensions for proper aspect ratio)
    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting - Enhanced for better visibility
    const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // Increased ambient intensity
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Full intensity
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Add point light for additional illumination
    const pointLight = new THREE.PointLight(0xffffff, 0.5, 50);
    pointLight.position.set(-10, 10, -10);
    scene.add(pointLight);
    
    // Create geometry and material
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.y = 1;
    scene.add(sphere);
    
    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(10, 10);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    // Set up controls
    controls.target.set(0, 0, 0);
    controls.update();
    
    console.log("Scene created with camera:", !!camera, "objects:", scene.children.length);
    
    return { scene, camera };
};

// Execute the scene creation and update global references
const sceneResult = createScene();
if (sceneResult && sceneResult.scene) {
    window.scene = sceneResult.scene;
    scene = sceneResult.scene;
}
if (sceneResult && sceneResult.camera) {
    window.camera = sceneResult.camera;
    camera = sceneResult.camera;
}

console.log("✅ Default scene creation complete!");`;
        }
        
        function createDefaultScene() {
            try {
                console.log('🎯 createDefaultScene called...');
                
                // Get current editor code or fall back to default
                const codeToRun = editor ? editor.getValue() : getDefaultCode();
                const isDefaultCode = !editor || editor.getValue() === getDefaultCode();
                
                console.log('🎯 Running code:', isDefaultCode ? 'DEFAULT CODE' : 'EDITOR CONTENT');
                console.log('🎯 Code length:', codeToRun.length);
                
                // Execute the code (this handles scene replacement)
                executeUserCode(codeToRun);
                
                hideError();
            } catch (error) {
                console.error('❌ createDefaultScene failed:', error);
                showError('Scene Creation Error: ' + error.message);
                
                // Create emergency fallback scene
                createFallbackScene();
            }
        }
        
        function clearScene() {
            if (scene) {
                console.log('🧹 Clearing scene objects (preserving lighting)...');
                
                // Only remove non-light objects to preserve lighting
                const objectsToRemove = [];
                
                // Collect non-light objects
                scene.children.forEach(child => {
                    if (!(child instanceof THREE.Light) && 
                        !child.isAmbientLight && 
                        !child.isDirectionalLight && 
                        !child.isPointLight && 
                        !child.isSpotLight && 
                        !child.isHemisphereLight) {
                        objectsToRemove.push(child);
                    }
                });
                
                // Remove and dispose non-light objects
                objectsToRemove.forEach(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                if (mat.map) mat.map.dispose();
                                mat.dispose();
                            });
                        } else {
                            if (object.material.map) object.material.map.dispose();
                            object.material.dispose();
                        }
                    }
                    scene.remove(object);
                });
                
                console.log('✅ Scene cleared, lights preserved:', scene.children.length, 'objects remaining');
            }
        }
        
        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING THREE.JS USER CODE ===');

                clearConsole();

                // Store old scene and camera for comparison
                const oldScene = scene;
                const oldCamera = camera;

                // Clear existing objects but preserve lighting
                clearScene();

                // Clean user code to remove conflicting animation loops
                // Remove standalone animate() function definitions that call composer.render()
                code = code.replace(/function\s+animate\s*\(\s*\)\s*\{[^}]*requestAnimationFrame\s*\(\s*animate\s*\)[^}]*composer\.render\s*\(\s*\)[^}]*\}\s*animate\s*\(\s*\)\s*;?/g, '');

                // Remove arrow function animate loops
                code = code.replace(/const\s+animate\s*=\s*\(\s*\)\s*=>\s*\{[^}]*requestAnimationFrame\s*\(\s*animate\s*\)[^}]*composer\.render\s*\(\s*\)[^}]*\}\s*;?\s*animate\s*\(\s*\)\s*;?/g, '');

                console.log('🧹 Cleaned user code to remove conflicting animation loops');

                // Execute the code in global context
                const executeCode = new Function('THREE', 'scene', 'camera', 'renderer', 'controls', 'canvas',
                    `try {
                        ${code}
                        
                        // Check if code created a new scene vs modifying existing
                        let resultScene = window.scene || scene;
                        let resultCamera = window.camera || camera;
                        
                        // If user code creates its own scene, use that
                        if (typeof createScene === 'function') {
                            const sceneResult = createScene();
                            if (sceneResult && sceneResult.scene) {
                                resultScene = sceneResult.scene;
                                resultCamera = sceneResult.camera || camera;
                            } else if (sceneResult && sceneResult.constructor === THREE.Scene) {
                                resultScene = sceneResult;
                            }
                        }
                        
                        return { scene: resultScene, camera: resultCamera };
                    } catch (execError) {
                        console.error('Code execution error:', execError);
                        throw execError;
                    }`
                );
                
                const result = executeCode(THREE, scene, camera, renderer, controls, canvas);
                
                // Handle scene replacement
                if (result && result.scene && result.scene !== oldScene) {
                    console.log('🔄 Replacing scene with new one');
                    scene = result.scene;
                    window.scene = result.scene;
                } else if (result && result.scene) {
                    console.log('🔧 Using modified existing scene');
                    scene = result.scene;
                    window.scene = result.scene;
                }
                
                // Handle camera replacement
                if (result && result.camera && result.camera !== oldCamera) {
                    console.log('📷 Replacing camera with new one');
                    camera = result.camera;
                    window.camera = result.camera;
                } else if (result && result.camera) {
                    camera = result.camera;
                    window.camera = result.camera;
                }
                
                // Ensure renderer uses correct canvas dimensions (fix common user error)
                const canvasWidth = canvas.clientWidth || 800;
                const canvasHeight = canvas.clientHeight || 600;
                renderer.setSize(canvasWidth, canvasHeight);
                
                // Fix camera aspect ratio if needed
                if (camera && camera.isPerspectiveCamera) {
                    camera.aspect = canvasWidth / canvasHeight;
                    camera.updateProjectionMatrix();
                }
                
                console.log('✅ Three.js scene created successfully');
                console.log('🎯 Renderer size:', renderer.getSize(new THREE.Vector2()));
                console.log('🎯 Canvas size:', canvas.clientWidth + 'x' + canvas.clientHeight);
                console.log('🎯 Scene children:', scene.children.length);
                console.log('🎯 Camera position:', camera.position);
                console.log('🎯 Scene background:', scene.background);
                console.log('🎯 Render loop running:', !!animationId);
                
                // Log scene composition for debugging
                if (scene.children.length > 0) {
                    console.log('🎯 Scene objects:', scene.children.map(child => child.constructor.name).join(', '));
                    const lightCount = scene.children.filter(child => child instanceof THREE.Light).length;
                    const meshCount = scene.children.filter(child => child instanceof THREE.Mesh).length;
                    console.log(`🎯 Scene composition: ${lightCount} lights, ${meshCount} meshes`);
                }
                
                // Force an immediate render to test
                if (scene && camera && renderer) {
                    console.log('🎯 Forcing immediate render test...');
                    renderer.render(scene, camera);
                }
                
                hideError();
                
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('❌ executeUserCode failed:', errorMsg);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Create fallback scene
                createFallbackScene();
            }
        }
        
        function createFallbackScene() {
            console.log('🚨 Creating Three.js EMERGENCY fallback scene...');
            
            try {
                clearScene();
                
                // Recreate scene and camera with global assignment
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x606060); // Light background for visibility
                
                camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
                
                // Enhanced lighting for fallback scene
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.5, 50);
                pointLight.position.set(-10, 10, -10);
                scene.add(pointLight);
                
                // Create bright green sphere for visibility
                const geometry = new THREE.SphereGeometry(1, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.y = 1;
                scene.add(sphere);
                
                // Add ground plane
                const groundGeometry = new THREE.PlaneGeometry(10, 10);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                scene.add(ground);
                
                // Set controls
                controls.target.set(0, 0, 0);
                controls.update();
                
                // Update global references
                window.scene = scene;
                window.camera = camera;
                
                console.log('✅ Fallback scene created with objects:', scene.children.length);
                console.log('✅ Fallback camera position:', camera.position);
                
                // Force immediate render
                if (renderer) {
                    renderer.render(scene, camera);
                    console.log('✅ Fallback scene rendered immediately');
                }
                
            } catch (fallbackError) {
                console.error('❌ CRITICAL: Even fallback scene creation failed:', fallbackError);
            }
        }
        
        // Playground functions
        function runCode() {
            console.log('🚀 Run code button pressed - executing current editor content');
            
            try {
                // Get current code from editor
                const currentCode = editor ? editor.getValue() : getDefaultCode();
                console.log('🎯 Executing code with length:', currentCode.length);
                
                // Execute the current code (this will replace the scene)
                executeUserCode(currentCode);
                
                notifySwift('codeRun', { success: true });
            } catch (error) {
                console.error('❌ runCode failed:', error);
                showError('Run Error: ' + error.message);
                notifySwift('codeRun', { success: false, error: error.message });
            }
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function openDocumentation() {
            // Open Three.js documentation in Safari
            window.location.href = 'https://threejs.org/docs/';
        }
        
        function initFloatingConsole() {
            const consoleWindow = document.getElementById('consoleWindow');
            const titleBar = document.getElementById('consoleTitleBar');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');
            const toggleBtn = document.getElementById('consoleToggleBtn');
            const closeBtn = document.getElementById('consoleCloseBtn');
            const resizeHandle = document.getElementById('consoleResizeHandle');
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');

            // Safety check - return if elements don't exist yet
            if (!consoleWindow || !titleBar || !minimizeBtn || !toggleBtn || !closeBtn || !resizeHandle || !consoleOpenBtn) {
                console.warn('Console elements not ready yet, skipping initialization');
                return;
            }

            // Load saved state from localStorage
            const saved = localStorage.getItem('threejs_console_state');
            if (saved) {
                consoleState = { ...consoleState, ...JSON.parse(saved) };
                applyConsoleState();
            }

            // Minimize button
            minimizeBtn.addEventListener('click', () => {
                consoleState.minimized = !consoleState.minimized;
                consoleWindow.classList.toggle('minimized', consoleState.minimized);
                minimizeBtn.textContent = consoleState.minimized ? '+' : '−';
                saveConsoleState();
            });

            // Toggle/Expand button
            toggleBtn.addEventListener('click', () => {
                if (consoleState.minimized) {
                    consoleState.minimized = false;
                    consoleWindow.classList.remove('minimized');
                    minimizeBtn.textContent = '−';
                }
                saveConsoleState();
            });

            // Close button
            closeBtn.addEventListener('click', () => {
                consoleState.hidden = true;
                consoleWindow.classList.add('hidden');
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Dragging
            let isDragging = false;
            let dragStartX, dragStartY, dragStartLeft, dragStartTop;

            titleBar.addEventListener('mousedown', startDrag);
            titleBar.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                if (e.target.closest('.console-btn')) return;
                isDragging = true;

                const rect = consoleWindow.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                dragStartX = clientX;
                dragStartY = clientY;
                dragStartLeft = rect.left;
                dragStartTop = rect.top;

                e.preventDefault();
            }

            function doDrag(e) {
                if (!isDragging) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - dragStartX;
                const deltaY = clientY - dragStartY;

                consoleState.x = dragStartLeft + deltaX;
                consoleState.y = dragStartTop + deltaY;

                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';

                e.preventDefault();
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);

            // Resizing
            let isResizingConsole = false;
            let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;

            resizeHandle.addEventListener('mousedown', startResize);
            resizeHandle.addEventListener('touchstart', startResize, { passive: false });

            function startResize(e) {
                isResizingConsole = true;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                resizeStartX = clientX;
                resizeStartY = clientY;
                resizeStartWidth = consoleWindow.offsetWidth;
                resizeStartHeight = consoleWindow.offsetHeight;

                e.preventDefault();
                e.stopPropagation();
            }

            function doResize(e) {
                if (!isResizingConsole) return;

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - resizeStartX;
                const deltaY = clientY - resizeStartY;

                consoleState.width = Math.max(300, Math.min(resizeStartWidth + deltaX, window.innerWidth * 0.9));
                consoleState.height = Math.max(200, Math.min(resizeStartHeight + deltaY, window.innerHeight * 0.8));

                consoleWindow.style.width = consoleState.width + 'px';
                consoleWindow.style.height = consoleState.height + 'px';

                e.preventDefault();
            }

            function stopResize() {
                if (isResizingConsole) {
                    isResizingConsole = false;
                    saveConsoleState();
                }
            }

            document.addEventListener('mousemove', doResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchend', stopResize);

            // Console Open Button (already declared at top of function)
            consoleOpenBtn.addEventListener('click', () => {
                consoleState.hidden = false;
                consoleState.minimized = false;
                consoleWindow.classList.remove('hidden');
                consoleWindow.classList.remove('minimized');
                minimizeBtn.textContent = '−';
                saveConsoleState();
                updateConsoleOpenButtonVisibility();
            });

            // Update button visibility based on console state
            updateConsoleOpenButtonVisibility();
        }

        function updateConsoleOpenButtonVisibility() {
            const consoleOpenBtn = document.getElementById('consoleOpenBtn');
            const consoleWindow = document.getElementById('consoleWindow');

            // Show button only when console is hidden
            if (consoleState.hidden) {
                consoleOpenBtn.classList.remove('hidden');
            } else {
                consoleOpenBtn.classList.add('hidden');
            }
        }

        function applyConsoleState() {
            const consoleWindow = document.getElementById('consoleWindow');
            const minimizeBtn = document.getElementById('consoleMinimizeBtn');

            if (consoleState.x !== null && consoleState.y !== null) {
                consoleWindow.style.left = consoleState.x + 'px';
                consoleWindow.style.top = consoleState.y + 'px';
                consoleWindow.style.right = 'auto';
                consoleWindow.style.bottom = 'auto';
            }

            consoleWindow.style.width = consoleState.width + 'px';
            consoleWindow.style.height = consoleState.height + 'px';

            consoleWindow.classList.toggle('minimized', consoleState.minimized);
            consoleWindow.classList.toggle('hidden', consoleState.hidden);
            minimizeBtn.textContent = consoleState.minimized ? '+' : '−';

            updateConsoleOpenButtonVisibility();
        }

        function saveConsoleState() {
            localStorage.setItem('threejs_console_state', JSON.stringify(consoleState));
        }

        function toggleConsole() {
            consoleState.hidden = !consoleState.hidden;
            document.getElementById('consoleWindow').classList.toggle('hidden', consoleState.hidden);
            saveConsoleState();
            updateConsoleOpenButtonVisibility();
            if (!consoleState.hidden && consoleMessages.length === 0) {
                console.log('Console opened - no messages yet');
            }
        }

        // Initialize console on page load
        window.addEventListener('DOMContentLoaded', initFloatingConsole);
        
        function loadExample(exampleId) {
            if (!exampleId) return;

            const examples = {
                'basic-scene': getDefaultCode(),
                'rotating-cube': getRotatingCubeCode(),
                'lighting': getLightingDemoCode(),
                'materials': getMaterialsDemoCode(),
                'rainbow': getRainbowCode(),
                'postprocessing': getPostprocessingCode()
            };

            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion functions with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('🎯 insertCodeAtCursor called with code length:', codeString.length);
            console.log('🔍 Three.js editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('✅ Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('✅ Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('❌ Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('⚠️ Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        // setFullEditorContent function already defined above
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management functions already defined above
        
        // Example code templates
        function getRotatingCubeCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000033); // Deep space blue

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);

    // Dramatic lighting
    const ambientLight = new THREE.AmbientLight(0x222244, 0.4);
    scene.add(ambientLight);

    // Multiple colored lights for dramatic effect
    const light1 = new THREE.PointLight(0xff0055, 2, 50);
    light1.position.set(5, 5, 5);
    scene.add(light1);

    const light2 = new THREE.PointLight(0x0055ff, 2, 50);
    light2.position.set(-5, 5, -5);
    scene.add(light2);
    
    // Create galaxy of glowing cubes
    const cubes = [];
    for (let i = 0; i < 50; i++) {
        const size = Math.random() * 0.5 + 0.2;
        const geometry = new THREE.BoxGeometry(size, size, size);
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1.0, 0.5);

        const material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.8,
            metalness: 0.5,
            roughness: 0.2
        });

        const cube = new THREE.Mesh(geometry, material);

        // Position in a sphere
        const radius = Math.random() * 5 + 2;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;

        cube.position.x = radius * Math.sin(phi) * Math.cos(theta);
        cube.position.y = radius * Math.sin(phi) * Math.sin(theta);
        cube.position.z = radius * Math.cos(phi);

        // Random rotation speeds
        cube.userData.rotationSpeed = {
            x: (Math.random() - 0.5) * 0.02,
            y: (Math.random() - 0.5) * 0.02,
            z: (Math.random() - 0.5) * 0.02
        };

        scene.add(cube);
        cubes.push(cube);
    }

    // Animation - rotate each cube
    function animate() {
        cubes.forEach(cube => {
            cube.rotation.x += cube.userData.rotationSpeed.x;
            cube.rotation.y += cube.userData.rotationSpeed.y;
            cube.rotation.z += cube.userData.rotationSpeed.z;
        });
    }

    scene.userData.animate = animate;

    controls.target.set(0, 0, 0);
    controls.update();

    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
        
        function getLightingDemoCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // Pure black for drama

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);

    // Dim ambient for mood
    const ambientLight = new THREE.AmbientLight(0x111122, 0.2);
    scene.add(ambientLight);

    // Animated colored lights orbiting the scene
    const light1 = new THREE.PointLight(0xff0040, 3, 20);
    scene.add(light1);

    const light2 = new THREE.PointLight(0x0080ff, 3, 20);
    scene.add(light2);

    const light3 = new THREE.PointLight(0x80ff00, 3, 20);
    scene.add(light3);

    // Light helper spheres (small glowing orbs)
    const lightSphere1 = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0040 })
    );
    light1.add(lightSphere1);

    const lightSphere2 = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x0080ff })
    );
    light2.add(lightSphere2);

    const lightSphere3 = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x80ff00 })
    );
    light3.add(lightSphere3);

    // Center crystal
    const geometry = new THREE.IcosahedronGeometry(2, 0);
    const material = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1,
        emissive: 0x222244,
        emissiveIntensity: 0.2
    });
    const crystal = new THREE.Mesh(geometry, material);
    crystal.position.y = 2;
    scene.add(crystal);

    // Ground with reflections
    const groundGeometry = new THREE.PlaneGeometry(30, 30);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111,
        metalness: 0.8,
        roughness: 0.3
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Animation - orbit lights around the crystal
    let time = 0;
    function animate() {
        time += 0.01;

        // Orbit lights in different patterns
        light1.position.x = Math.cos(time) * 6;
        light1.position.z = Math.sin(time) * 6;
        light1.position.y = 3 + Math.sin(time * 2) * 2;

        light2.position.x = Math.cos(time + Math.PI * 2/3) * 6;
        light2.position.z = Math.sin(time + Math.PI * 2/3) * 6;
        light2.position.y = 3 + Math.sin(time * 2 + Math.PI * 2/3) * 2;

        light3.position.x = Math.cos(time + Math.PI * 4/3) * 6;
        light3.position.z = Math.sin(time + Math.PI * 4/3) * 6;
        light3.position.y = 3 + Math.sin(time * 2 + Math.PI * 4/3) * 2;

        // Slowly rotate crystal
        crystal.rotation.y += 0.003;
        crystal.rotation.x += 0.002;
    }

    scene.userData.animate = animate;

    controls.target.set(0, 2, 0);
    controls.update();

    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
        
        function getMaterialsDemoCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Different materials
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    
    // Basic material
    const basicMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const basicSphere = new THREE.Mesh(geometry, basicMaterial);
    basicSphere.position.set(-3, 1, 0);
    scene.add(basicSphere);
    
    // Phong material
    const phongMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x00ff00,
        shininess: 100
    });
    const phongSphere = new THREE.Mesh(geometry, phongMaterial);
    phongSphere.position.set(0, 1, 0);
    scene.add(phongSphere);
    
    // Standard material
    const standardMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0000ff,
        metalness: 0.5,
        roughness: 0.1
    });
    const standardSphere = new THREE.Mesh(geometry, standardMaterial);
    standardSphere.position.set(3, 1, 0);
    scene.add(standardSphere);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }

        function getRainbowCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 12);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    // Rainbow colors
    const rainbowColors = [
        0xFF0000, // Red
        0xFF7F00, // Orange
        0xFFFF00, // Yellow
        0x00FF00, // Green
        0x0000FF, // Blue
        0x4B0082, // Indigo
        0x9400D3  // Violet
    ];

    // Create rainbow arc using spheres
    const numSpheres = 80;
    const radius = 6;
    const arcAngle = Math.PI * 0.6; // 60% of a circle

    for (let i = 0; i < numSpheres; i++) {
        const colorIndex = Math.floor((i / numSpheres) * rainbowColors.length);
        const geometry = new THREE.SphereGeometry(0.15, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: rainbowColors[colorIndex],
            emissive: rainbowColors[colorIndex],
            emissiveIntensity: 0.5,
            metalness: 0.3,
            roughness: 0.4
        });
        const sphere = new THREE.Mesh(geometry, material);

        // Position spheres in an arc
        const angle = (i / numSpheres) * arcAngle - arcAngle / 2;
        sphere.position.x = radius * Math.cos(angle);
        sphere.position.y = 2 + radius * Math.sin(angle) - 2;
        sphere.position.z = 0;

        scene.add(sphere);
    }

    // Add some clouds
    for (let i = 0; i < 5; i++) {
        const cloudGeometry = new THREE.SphereGeometry(0.8, 8, 8);
        const cloudMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.7
        });
        const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
        cloud.position.set(
            (Math.random() - 0.5) * 10,
            Math.random() * 2 + 1,
            (Math.random() - 0.5) * 5
        );
        cloud.scale.set(1 + Math.random(), 0.5 + Math.random() * 0.3, 1 + Math.random());
        scene.add(cloud);
    }

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(30, 30);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 }); // Forest green
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1;
    scene.add(ground);

    controls.target.set(0, 2, 0);
    controls.update();

    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }

        function getPostprocessingCode() {
            return `// Three.js r160 Postprocessing Example - Bloom Effect
// This demonstrates the UnrealBloomPass for glowing effects

const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011); // Dark space background

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);

    // Basic lighting
    const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);

    // Create glowing spheres
    const colors = [0xff0055, 0x0055ff, 0x00ff55, 0xff5500, 0x5500ff];
    const spheres = [];

    for (let i = 0; i < 5; i++) {
        const geometry = new THREE.SphereGeometry(0.8, 32, 32);
        const material = new THREE.MeshStandardMaterial({
            color: colors[i],
            emissive: colors[i],
            emissiveIntensity: 1.0,
            metalness: 0.5,
            roughness: 0.2
        });

        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.x = (i - 2) * 3;
        sphere.position.y = 2;

        // Store animation data
        sphere.userData.speed = 0.02 + Math.random() * 0.02;
        sphere.userData.offset = i * Math.PI * 0.4;

        scene.add(sphere);
        spheres.push(sphere);
    }

    // Ground plane
    const groundGeometry = new THREE.PlaneGeometry(30, 30);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x111122,
        metalness: 0.8,
        roughness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Set up postprocessing
    const composer = new EffectComposer(renderer);

    // Add render pass
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Add bloom pass
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,  // strength
        0.4,  // radius
        0.85  // threshold
    );
    composer.addPass(bloomPass);

    // Add output pass
    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // Animation function (will be called by main render loop)
    let time = 0;
    function animate() {
        time += 0.01;

        spheres.forEach((sphere, i) => {
            // Floating animation
            sphere.position.y = 2 + Math.sin(time + sphere.userData.offset) * 0.5;
            // Rotation
            sphere.rotation.y += sphere.userData.speed;
            sphere.rotation.x += sphere.userData.speed * 0.5;
        });
    }

    // Store animation and composer so main render loop can use them
    scene.userData.animate = animate;
    scene.userData.composer = composer;

    controls.target.set(0, 2, 0);
    controls.update();

    console.log("✨ Postprocessing scene created with bloom effect!");

    return { scene, camera };
};

const { scene, camera } = createScene();

console.log("✅ Bloom postprocessing enabled - scene will render with glow effect!");`;
        }
    </script>
</body>
</html>