<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Playground</title>
    
    <!-- Three.js Core -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js" onerror="console.error('‚ùå Failed to load Three.js library')"></script>
    <!-- OrbitControls temporarily disabled to focus on Monaco fix -->
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js" onerror="console.error('‚ùå Failed to load Monaco loader')"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #ff8c1a;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        
        .editor-container {
            flex: 0 0 50%;
            width: 50%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .canvas-container {
            flex: 0 0 50%;
            width: 50%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .resize-handle {
            position: absolute;
            top: 0;
            right: -2px;
            width: 4px;
            height: 100%;
            background: #3e3e42;
            cursor: col-resize;
            z-index: 10;
        }
        
        .resize-handle:hover {
            background: #ff6b35;
        }
        
        .footer {
            background: #ff6b35;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        .console-display {
            position: absolute;
            bottom: 10px;
            left: 50%; /* Start from middle of screen (after editor) */
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            color: #ccc;
            padding: 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            border: 1px solid #3e3e42;
        }
        
        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
        }
        
        .console-error {
            color: #f14c4c;
        }
        
        .console-warning {
            color: #ffcc02;
        }
        
        .console-log {
            color: #ccc;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .editor-container {
                width: 100%;
                height: 50%;
                border-right: none;
                border-bottom: 1px solid #3e3e42;
            }
            
            .canvas-container {
                width: 100%;
                height: 50%;
            }
            
            .resize-handle {
                top: -2px;
                right: 0;
                width: 100%;
                height: 4px;
                cursor: row-resize;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">‚ñ∂ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">üóë Clear</button>
        <button class="menu-btn" onclick="saveScene()">üíæ Save</button>
        <button class="menu-btn" onclick="downloadScene()">‚¨á Download</button>
        <button class="menu-btn" onclick="newScene()">üìÑ New</button>
        <button class="menu-btn" onclick="showExamples()">üìö Examples</button>
        <button class="menu-btn" onclick="toggleConsole()">üñ• Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Select Example...</option>
            <option value="basic-scene">Basic Scene</option>
            <option value="rotating-cube">Rotating Cube</option>
            <option value="lighting">Lighting Demo</option>
            <option value="materials">Materials Demo</option>
        </select>
    </div>
    
    <div class="main-container">
        <div class="editor-container">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <div class="resize-handle"></div>
        </div>
        <div class="canvas-container">
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Three.js...</div>
        </div>
    </div>
    
    <div class="footer">
        Three.js Playground - Powered by WebGL
    </div>
    
    <div class="error-display" id="errorDisplay"></div>
    <div class="console-display" id="consoleDisplay"></div>

    <script>
        // IMMEDIATE LOGGING TO DEBUG THREE.JS TEMPLATE LOADING
        console.log('üöÄ THREE.JS TEMPLATE SCRIPT STARTING...');
        console.log('üîç Three.js availability:', typeof THREE !== 'undefined');
        console.log('üîç Monaco availability:', typeof monaco !== 'undefined');
        console.log('üîç Document state:', document.readyState);
        console.log('üîç Window loaded:', document.readyState === 'complete');
        
        let editor;
        let renderer;
        let scene;
        let camera;
        let controls;
        let canvas;
        let animationId;
        let isResizing = false;
        let consoleMessages = [];
        
        console.log('‚úÖ Three.js template variables initialized');
        
        // Console management functions (must be defined before console overrides)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function updateConsoleDisplay() {
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleMessages.length > 0) {
                consoleDisplay.innerHTML = consoleMessages.map(msg => 
                    `<div class="console-message console-${msg.type}">${escapeHtml(msg.message)}</div>`
                ).join('');
                consoleDisplay.style.display = 'block';
                consoleDisplay.scrollTop = consoleDisplay.scrollHeight;
            } else {
                consoleDisplay.style.display = 'none';
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50);
            }
            updateConsoleDisplay();
        }
        
        // Define critical injection functions BEFORE Monaco initialization
        function setFullEditorContent(codeString) {
            console.log('üéØ Three.js setFullEditorContent called with code length:', codeString.length);
            console.log('üîç Three.js editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy for Three.js
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('üìù Three.js Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('‚úÖ Three.js Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('‚ö†Ô∏è Three.js Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('üìù Three.js Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('‚úÖ Three.js Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('üìù Three.js Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('‚úÖ Three.js Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('‚ùå Three.js Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`üéâ Three.js content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('üöÄ Auto-running the injected Three.js code...');
                                runCode();
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true,
                                library: 'threejs'
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`‚ùå Three.js Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('‚ùå All Three.js injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All Three.js injection strategies failed',
                    library: 'threejs'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
            // Auto-show console for critical errors
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay) {
                consoleDisplay.style.display = 'block';
            }
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
            // Auto-show console for warnings
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay) {
                consoleDisplay.style.display = 'block';
            }
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Global error handler to catch uncaught errors
        window.addEventListener('error', function(event) {
            console.error('‚ùå UNCAUGHT ERROR:', event.error);
            console.error('‚ùå Error message:', event.message);
            console.error('‚ùå Error source:', event.filename + ':' + event.lineno);
            if (event.error && event.error.stack) {
                console.error('‚ùå Stack trace:', event.error.stack);
            }
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('‚ùå UNHANDLED PROMISE REJECTION:', event.reason);
        });

        // Initialize Monaco Editor with enhanced error handling and fallback
        console.log('Starting Monaco Editor initialization...');
        
        // Set longer timeout for CDN loading
        let monacoTimeout = setTimeout(() => {
            console.error('‚ùå Monaco Editor CDN loading timeout - creating fallback editor');
            createFallbackEditor();
        }, 10000); // 10 second timeout
        
        require.config({ 
            paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' },
            waitSeconds: 30 // Increase wait time for CDN
        });
        
        require(['vs/editor/editor.main'], function () {
            clearTimeout(monacoTimeout); // Cancel timeout since loading succeeded
            console.log('‚úÖ Monaco modules loaded successfully, creating editor...');
            
            try {
                const editorContainer = document.getElementById('monaco-editor');
                if (!editorContainer) {
                    throw new Error('Monaco editor container not found');
                }
                
                editor = monaco.editor.create(editorContainer, {
                    value: getDefaultCode(),
                    language: 'javascript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('‚úÖ Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible with multiple references
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                        // Simple readiness check - simplified to match working Babylon.js exactly
                if (editor && editor.getModel && typeof editor.setValue === 'function') {
                    // Mark as ready immediately like Babylon.js does
                    window.editorReady = true;
                    console.log('‚úÖ Monaco editor ready for injection');
                    
                    // Initialize Three.js after Monaco is confirmed ready
                    initializeThreeJS();
                } else {
                    console.error('‚ùå Monaco editor creation failed');
                    createFallbackEditor();
                }
                
                
            } catch (editorError) {
                console.error('‚ùå Failed to create Monaco editor:', editorError);
                createFallbackEditor();
            }
        }, function(error) {
            clearTimeout(monacoTimeout);
            console.error('‚ùå Failed to load Monaco from CDN:', error);
            createFallbackEditor();
        });
        
        // Fallback editor function
        function createFallbackEditor() {
            console.log('üîß Creating fallback textarea editor...');
            
            const editorContainer = document.getElementById('monaco-editor');
            if (!editorContainer) {
                console.error('‚ùå Editor container not found');
                return;
            }
            
            // Create a textarea fallback
            editorContainer.innerHTML = '<textarea id="fallback-editor" style="width: 100%; height: 100%; background: #1e1e1e; color: #fff; font-family: \'Monaco\', \'Consolas\', monospace; font-size: 14px; border: none; outline: none; padding: 10px;"></textarea>';
            
            const textarea = document.getElementById('fallback-editor');
            if (textarea) {
                textarea.value = getDefaultCode();
                
                // Create minimal editor interface
                window.editor = {
                    setValue: (code) => { textarea.value = code; },
                    getValue: () => textarea.value,
                    getModel: () => ({ setValue: (code) => textarea.value = code }),
                    layout: () => {},
                    focus: () => textarea.focus(),
                    setPosition: () => {},
                    onDidChangeModelContent: (callback) => {
                        textarea.addEventListener('input', callback);
                        return { dispose: () => {} };
                    }
                };
                
                window.monacoEditor = window.editor;
                window.codeEditor = window.editor;
                
                // Auto-save on changes
                textarea.addEventListener('input', () => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Mark as ready
                window.editorReady = true;
                console.log('‚úÖ Fallback editor ready for injection');
                
                // Initialize Three.js
                initializeThreeJS();
            }
        }
        
        // Initialize Three.js with comprehensive error handling
        function initializeThreeJS() {
            console.log('üöÄ Initializing Three.js...');
            
            try {
                // Check if THREE is available
                if (typeof THREE === 'undefined') {
                    console.error('‚ùå CRITICAL: THREE.js library not loaded from CDN');
                    throw new Error('THREE.js library not loaded - check network connection');
                }
                
                canvas = document.getElementById('renderCanvas');
                if (!canvas) {
                    console.error('‚ùå CRITICAL: Canvas element not found in DOM');
                    throw new Error('Canvas element not found');
                }
                
                console.log('‚úÖ Canvas found:', canvas.clientWidth + 'x' + canvas.clientHeight);
                console.log('‚úÖ THREE.js version available:', THREE.REVISION);
                
                // Create renderer with error handling
                console.log('üé® Creating WebGL renderer...');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    preserveDrawingBuffer: true
                });
                
                const canvasWidth = canvas.clientWidth || 800;
                const canvasHeight = canvas.clientHeight || 600;
                renderer.setSize(canvasWidth, canvasHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                console.log('‚úÖ Three.js renderer created successfully:', canvasWidth + 'x' + canvasHeight);
                
                // Test renderer capabilities
                const gl = renderer.getContext();
                if (!gl) {
                    console.error('‚ùå CRITICAL: WebGL context not available');
                    throw new Error('WebGL not supported');
                }
                console.log('‚úÖ WebGL context created successfully');
                
            } catch (rendererError) {
                console.error('‚ùå CRITICAL: Three.js renderer creation failed:', rendererError);
                console.error('‚ùå Error stack:', rendererError.stack);
                return; // Don't continue if renderer fails
            }
            
            try {
                // Create default scene and camera
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, (canvas.clientWidth || 800) / (canvas.clientHeight || 600), 0.1, 1000);
                console.log('‚úÖ Scene and camera created');
            } catch (sceneError) {
                console.error('‚ùå Scene/camera creation failed:', sceneError);
                return;
            }
            
            // Set up camera position and create mock controls
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Create mock controls object to prevent undefined errors
            controls = {
                target: { x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; } },
                update: function() {},
                enableDamping: false,
                dampingFactor: 0.05
            };
            
            console.log('‚úÖ Camera positioned with mock controls');
            
            // Make globals available
            window.canvas = canvas;
            window.renderer = renderer;
            window.scene = scene;
            window.camera = camera;
            window.controls = controls;
            window.THREE = THREE;
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Create default scene
            createDefaultScene();
            
            // Start render loop
            startRenderLoop();
            
            console.log('Three.js initialization complete');
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Three.js playground fully initialized');
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!renderer 
                });
            }, 1500);
        }
        
        function startRenderLoop() {
            console.log('üé¨ Starting Three.js render loop...');
            let frameCount = 0;
            
            function animate() {
                animationId = requestAnimationFrame(animate);
                frameCount++;
                
                // Debug every 60 frames (about once per second at 60fps)
                if (frameCount % 60 === 0) {
                    console.log('üé¨ Render loop active, frame:', frameCount, 'scene children:', scene?.children?.length || 0);
                }
                
                controls.update();
                
                if (scene && camera && renderer) {
                    renderer.render(scene, camera);
                } else if (frameCount < 10) {
                    console.log('‚ö†Ô∏è Missing components - scene:', !!scene, 'camera:', !!camera, 'renderer:', !!renderer);
                }
            }
            animate();
        }
        
        function onWindowResize() {
            if (camera && renderer && canvas) {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }
        
        function getDefaultCode() {
            return `// Welcome to Three.js Playground!
// Create your 3D scene using Three.js r160+

const createScene = () => {
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x606060); // Even lighter background for better visibility
    
    // Create camera (use canvas dimensions for proper aspect ratio)
    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting - Enhanced for better visibility
    const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // Increased ambient intensity
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Full intensity
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Add point light for additional illumination
    const pointLight = new THREE.PointLight(0xffffff, 0.5, 50);
    pointLight.position.set(-10, 10, -10);
    scene.add(pointLight);
    
    // Create geometry and material
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.y = 1;
    scene.add(sphere);
    
    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(10, 10);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    // Set up controls
    controls.target.set(0, 0, 0);
    controls.update();
    
    console.log("Scene created with camera:", !!camera, "objects:", scene.children.length);
    
    return { scene, camera };
};

// Execute the scene creation
const { scene, camera } = createScene();`;
        }
        
        function createDefaultScene() {
            try {
                // Clear existing scene
                clearScene();
                
                // Execute user code
                const userCode = editor ? editor.getValue() : getDefaultCode();
                executeUserCode(userCode);
                
                hideError();
            } catch (error) {
                showError('Scene Creation Error: ' + error.message);
                console.error('Scene creation error:', error);
            }
        }
        
        function clearScene() {
            if (scene) {
                // Remove all objects from scene
                while(scene.children.length > 0) {
                    const object = scene.children[0];
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (object.material.map) object.material.map.dispose();
                        object.material.dispose();
                    }
                    scene.remove(object);
                }
            }
        }
        
        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING THREE.JS USER CODE ===');
                
                clearConsole();
                clearScene();
                
                // Execute the code in global context
                const executeCode = new Function('THREE', 'scene', 'camera', 'renderer', 'controls', 'canvas',
                    `try {
                        ${code}
                        return { scene: window.scene || scene, camera: window.camera || camera };
                    } catch (execError) {
                        console.error('Code execution error:', execError);
                        throw execError;
                    }`
                );
                
                const result = executeCode(THREE, scene, camera, renderer, controls, canvas);
                
                if (result && result.scene) {
                    window.scene = result.scene;
                    scene = result.scene;
                }
                if (result && result.camera) {
                    window.camera = result.camera;
                    camera = result.camera;
                }
                
                // Ensure renderer uses correct canvas dimensions (fix common user error)
                const canvasWidth = canvas.clientWidth || 800;
                const canvasHeight = canvas.clientHeight || 600;
                renderer.setSize(canvasWidth, canvasHeight);
                
                // Fix camera aspect ratio if needed
                if (camera && camera.isPerspectiveCamera) {
                    camera.aspect = canvasWidth / canvasHeight;
                    camera.updateProjectionMatrix();
                }
                
                console.log('‚úÖ Three.js scene created successfully');
                console.log('üéØ Renderer size:', renderer.getSize(new THREE.Vector2()));
                console.log('üéØ Canvas size:', canvas.clientWidth + 'x' + canvas.clientHeight);
                console.log('üéØ Scene children:', scene.children.length);
                console.log('üéØ Camera position:', camera.position);
                console.log('üéØ Scene background:', scene.background);
                console.log('üéØ Render loop running:', !!animationId);
                
                // Force an immediate render to test
                if (scene && camera && renderer) {
                    console.log('üéØ Forcing immediate render test...');
                    renderer.render(scene, camera);
                }
                
                hideError();
                
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('‚ùå executeUserCode failed:', errorMsg);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Create fallback scene
                createFallbackScene();
            }
        }
        
        function createFallbackScene() {
            console.log('Creating Three.js fallback scene');
            clearScene();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x606060); // Even lighter background
            
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Enhanced lighting for fallback scene
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Use MeshPhongMaterial instead of Basic to show lighting effects
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.y = 1; // Lift cube off ground
            scene.add(cube);
            
            // Add ground plane
            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            controls.target.set(0, 0, 0);
            controls.update();
            
            window.scene = scene;
            window.camera = camera;
        }
        
        // Playground functions
        function runCode() {
            console.log('Run code button pressed');
            createDefaultScene();
            notifySwift('codeRun', {});
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function showExamples() {
            notifySwift('showExamples', {});
        }
        
        function toggleConsole() {
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay.style.display === 'none' || !consoleDisplay.style.display) {
                updateConsoleDisplay();
                if (consoleMessages.length === 0) {
                    console.log('Console opened - no messages yet');
                }
                console.log('üì∫ Console is now visible (positioned over canvas area)');
            } else {
                consoleDisplay.style.display = 'none';
                console.log('üì∫ Console hidden');
            }
        }
        
        // Show console by default for debugging
        setTimeout(() => {
            console.log('üîß Auto-showing console for debugging...');
            toggleConsole();
        }, 2000);
        
        function loadExample(exampleId) {
            if (!exampleId) return;
            
            const examples = {
                'basic-scene': getDefaultCode(),
                'rotating-cube': getRotatingCubeCode(),
                'lighting': getLightingDemoCode(),
                'materials': getMaterialsDemoCode()
            };
            
            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion functions with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('üéØ insertCodeAtCursor called with code length:', codeString.length);
            console.log('üîç Three.js editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('‚úÖ Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('‚úÖ Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('‚ö†Ô∏è Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        // setFullEditorContent function already defined above
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management functions already defined above
        
        // Example code templates
        function getRotatingCubeCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Create rotating cube
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshPhongMaterial({ color: 0xff6b35 });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.y = 1;
    scene.add(cube);
    
    // Animation
    function animate() {
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
    }
    
    // Register animation
    scene.userData.animate = animate;
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
        
        function getLightingDemoCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Multiple lights
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0xff6b35, 1, 100);
    pointLight.position.set(-5, 5, 5);
    scene.add(pointLight);
    
    // Objects
    const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.set(-2, 1, 0);
    scene.add(sphere);
    
    const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
    const boxMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b35 });
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    box.position.set(2, 1, 0);
    scene.add(box);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
        
        function getMaterialsDemoCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Different materials
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    
    // Basic material
    const basicMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const basicSphere = new THREE.Mesh(geometry, basicMaterial);
    basicSphere.position.set(-3, 1, 0);
    scene.add(basicSphere);
    
    // Phong material
    const phongMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x00ff00,
        shininess: 100
    });
    const phongSphere = new THREE.Mesh(geometry, phongMaterial);
    phongSphere.position.set(0, 1, 0);
    scene.add(phongSphere);
    
    // Standard material
    const standardMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0000ff,
        metalness: 0.5,
        roughness: 0.1
    });
    const standardSphere = new THREE.Mesh(geometry, standardMaterial);
    standardSphere.position.set(3, 1, 0);
    scene.add(standardSphere);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
    </script>
</body>
</html>