<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Playground</title>
    
    <!-- Three.js Core -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js" onerror="console.error('❌ Failed to load Three.js library')"></script>
    <!-- OrbitControls temporarily disabled to focus on Monaco fix -->
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js" onerror="console.error('❌ Failed to load Monaco loader')"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #ff8c1a;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        
        .editor-container {
            width: 0%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease-in-out;
        }

        .editor-container.open {
            width: 50%;
        }

        .canvas-container {
            width: 100%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.3s ease-in-out;
        }

        .canvas-container.editor-open {
            width: 50%;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .resize-handle {
            position: absolute;
            top: 0;
            right: -2px;
            width: 4px;
            height: 100%;
            background: #3e3e42;
            cursor: col-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .editor-container.open .resize-handle {
            opacity: 1;
        }

        .resize-handle:hover {
            background: #ff6b35;
        }

        .editor-toggle-btn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 12px 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            z-index: 20;
            transition: all 0.3s ease-in-out;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .editor-toggle-btn:hover {
            background: #ff8c1a;
            padding-left: 12px;
        }

        .editor-toggle-btn:active {
            background: #ff5722;
        }

        .editor-toggle-btn.editor-open {
            left: -60px;
            opacity: 0;
            pointer-events: none;
        }
        
        .footer {
            background: #ff6b35;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        .console-display {
            position: absolute;
            bottom: 10px;
            left: 50%; /* Start from middle of screen (after editor) */
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            color: #ccc;
            padding: 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            border: 1px solid #3e3e42;
        }
        
        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
        }
        
        .console-error {
            color: #f14c4c;
        }
        
        .console-warning {
            color: #ffcc02;
        }
        
        .console-log {
            color: #ccc;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        /* Remove media query - same behavior across all devices per requirements */
        /* The editor starts hidden (width: 0%) on all screen sizes */
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">▶ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">🗑 Clear</button>
        <button class="menu-btn" onclick="saveScene()">💾 Save</button>
        <button class="menu-btn" onclick="downloadScene()">⬇ Download</button>
        <button class="menu-btn" onclick="newScene()">📄 New</button>
        <button class="menu-btn" onclick="showExamples()">📚 Examples</button>
        <button class="menu-btn" onclick="toggleConsole()">🖥 Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Select Example...</option>
            <option value="basic-scene">Basic Scene</option>
            <option value="rotating-cube">Rotating Cube</option>
            <option value="lighting">Lighting Demo</option>
            <option value="materials">Materials Demo</option>
        </select>
    </div>
    
    <div class="main-container">
        <div class="editor-container" id="editorContainer">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <div class="resize-handle" id="resizeHandle"></div>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <button class="editor-toggle-btn" id="editorToggleBtn" onclick="toggleEditor()">CODE</button>
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Three.js...</div>
        </div>
    </div>
    
    <div class="footer">
        Three.js Playground - Powered by WebGL
    </div>
    
    <div class="error-display" id="errorDisplay"></div>
    <div class="console-display" id="consoleDisplay"></div>

    <script>
        // IMMEDIATE LOGGING TO DEBUG THREE.JS TEMPLATE LOADING
        console.log('🚀 THREE.JS TEMPLATE SCRIPT STARTING...');
        console.log('🔍 Three.js availability:', typeof THREE !== 'undefined');
        console.log('🔍 Monaco availability:', typeof monaco !== 'undefined');
        console.log('🔍 Document state:', document.readyState);
        console.log('🔍 Window loaded:', document.readyState === 'complete');
        
        let editor;
        let renderer;
        let scene;
        let camera;
        let controls;
        let canvas;
        let animationId;
        let isResizing = false;
        let consoleMessages = [];
        let isEditorOpen = false;

        // Editor toggle and resize functionality
        function toggleEditor() {
            isEditorOpen = !isEditorOpen;
            const editorContainer = document.getElementById('editorContainer');
            const canvasContainer = document.getElementById('canvasContainer');
            const toggleBtn = document.getElementById('editorToggleBtn');

            if (isEditorOpen) {
                editorContainer.classList.add('open');
                canvasContainer.classList.add('editor-open');
                toggleBtn.classList.add('editor-open');

                // Trigger Monaco layout after transition completes
                setTimeout(() => {
                    if (editor && typeof editor.layout === 'function') {
                        editor.layout();
                    }
                }, 300);
            } else {
                editorContainer.classList.remove('open');
                canvasContainer.classList.remove('editor-open');
                toggleBtn.classList.remove('editor-open');
            }

            // Resize canvas and renderer
            if (renderer && camera) {
                setTimeout(() => {
                    const canvas = document.getElementById('renderCanvas');
                    if (canvas) {
                        camera.aspect = canvas.clientWidth / canvas.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                    }
                }, 350);
            }
        }

        // Draggable divider functionality with touch support
        function initResizeHandle() {
            const resizeHandle = document.getElementById('resizeHandle');
            const editorContainer = document.getElementById('editorContainer');
            const canvasContainer = document.getElementById('canvasContainer');
            const mainContainer = document.querySelector('.main-container');

            let startX = 0;
            let startEditorWidth = 0;

            function startResize(e) {
                if (!isEditorOpen) return;

                isResizing = true;
                startX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                startEditorWidth = editorContainer.offsetWidth;

                // Disable transitions during drag
                editorContainer.style.transition = 'none';
                canvasContainer.style.transition = 'none';

                e.preventDefault();
            }

            function doResize(e) {
                if (!isResizing || !isEditorOpen) return;

                const currentX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const diff = currentX - startX;
                const containerWidth = mainContainer.offsetWidth;

                // Calculate new width as percentage
                let newEditorWidth = startEditorWidth + diff;
                let newEditorPercent = (newEditorWidth / containerWidth) * 100;

                // Clamp between 20% and 80%
                newEditorPercent = Math.max(20, Math.min(80, newEditorPercent));
                const newCanvasPercent = 100 - newEditorPercent;

                editorContainer.style.width = newEditorPercent + '%';
                canvasContainer.style.width = newCanvasPercent + '%';

                // Update Monaco layout
                if (editor && typeof editor.layout === 'function') {
                    editor.layout();
                }

                // Resize Three.js renderer
                if (renderer && camera) {
                    const canvas = document.getElementById('renderCanvas');
                    if (canvas) {
                        camera.aspect = canvas.clientWidth / canvas.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                    }
                }

                e.preventDefault();
            }

            function stopResize(e) {
                if (isResizing) {
                    isResizing = false;

                    // Re-enable transitions
                    editorContainer.style.transition = 'width 0.3s ease-in-out';
                    canvasContainer.style.transition = 'width 0.3s ease-in-out';

                    e.preventDefault();
                }
            }

            // Mouse events
            resizeHandle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);

            // Touch events for iOS
            resizeHandle.addEventListener('touchstart', startResize, { passive: false });
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('touchend', stopResize, { passive: false });
        }

        // Initialize resize handle when DOM is ready
        window.addEventListener('DOMContentLoaded', initResizeHandle);
        
        console.log('✅ Three.js template variables initialized');
        
        // Console management functions (must be defined before console overrides)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function updateConsoleDisplay() {
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleMessages.length > 0) {
                consoleDisplay.innerHTML = consoleMessages.map(msg => 
                    `<div class="console-message console-${msg.type}">${escapeHtml(msg.message)}</div>`
                ).join('');
                consoleDisplay.style.display = 'block';
                consoleDisplay.scrollTop = consoleDisplay.scrollHeight;
            } else {
                consoleDisplay.style.display = 'none';
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50);
            }
            updateConsoleDisplay();
        }
        
        // Define critical injection functions BEFORE Monaco initialization
        function setFullEditorContent(codeString) {
            console.log('🎯 Three.js setFullEditorContent called with code length:', codeString.length);
            console.log('🔍 Three.js editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy for Three.js
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('📝 Three.js Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('✅ Three.js Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('⚠️ Three.js Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('📝 Three.js Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('✅ Three.js Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('📝 Three.js Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('✅ Three.js Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('❌ Three.js Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`🎉 Three.js content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('🚀 Auto-running the injected Three.js code...');
                                runCode();
                                
                                // Force immediate render after code injection
                                if (scene && camera && renderer) {
                                    renderer.render(scene, camera);
                                    console.log('🎯 Forced immediate render after code injection');
                                }
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true,
                                library: 'threejs'
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`❌ Three.js Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('❌ All Three.js injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All Three.js injection strategies failed',
                    library: 'threejs'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
            // Auto-show console for critical errors
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay) {
                consoleDisplay.style.display = 'block';
            }
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
            // Auto-show console for warnings
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay) {
                consoleDisplay.style.display = 'block';
            }
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Global error handler to catch uncaught errors
        window.addEventListener('error', function(event) {
            console.error('❌ UNCAUGHT ERROR:', event.error);
            console.error('❌ Error message:', event.message);
            console.error('❌ Error source:', event.filename + ':' + event.lineno);
            if (event.error && event.error.stack) {
                console.error('❌ Stack trace:', event.error.stack);
            }
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('❌ UNHANDLED PROMISE REJECTION:', event.reason);
        });

        // Initialize Monaco Editor with enhanced error handling and fallback
        console.log('Starting Monaco Editor initialization...');
        
        // Set longer timeout for CDN loading
        let monacoTimeout = setTimeout(() => {
            console.error('❌ Monaco Editor CDN loading timeout - creating fallback editor');
            createFallbackEditor();
        }, 10000); // 10 second timeout
        
        require.config({ 
            paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' },
            waitSeconds: 30 // Increase wait time for CDN
        });
        
        require(['vs/editor/editor.main'], function () {
            clearTimeout(monacoTimeout); // Cancel timeout since loading succeeded
            console.log('✅ Monaco modules loaded successfully, creating editor...');
            
            try {
                const editorContainer = document.getElementById('monaco-editor');
                if (!editorContainer) {
                    throw new Error('Monaco editor container not found');
                }
                
                editor = monaco.editor.create(editorContainer, {
                    value: getDefaultCode(),
                    language: 'javascript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('✅ Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible with multiple references
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                        // Simple readiness check - simplified to match working Babylon.js exactly
                if (editor && editor.getModel && typeof editor.setValue === 'function') {
                    // Mark as ready immediately like Babylon.js does
                    window.editorReady = true;
                    console.log('✅ Monaco editor ready for injection');
                    
                    // Initialize Three.js after Monaco is confirmed ready
                    initializeThreeJS();
                } else {
                    console.error('❌ Monaco editor creation failed');
                    createFallbackEditor();
                }
                
                
            } catch (editorError) {
                console.error('❌ Failed to create Monaco editor:', editorError);
                createFallbackEditor();
            }
        }, function(error) {
            clearTimeout(monacoTimeout);
            console.error('❌ Failed to load Monaco from CDN:', error);
            createFallbackEditor();
        });
        
        // Fallback editor function
        function createFallbackEditor() {
            console.log('🔧 Creating fallback textarea editor...');
            
            const editorContainer = document.getElementById('monaco-editor');
            if (!editorContainer) {
                console.error('❌ Editor container not found');
                return;
            }
            
            // Create a textarea fallback
            editorContainer.innerHTML = '<textarea id="fallback-editor" style="width: 100%; height: 100%; background: #1e1e1e; color: #fff; font-family: \'Monaco\', \'Consolas\', monospace; font-size: 14px; border: none; outline: none; padding: 10px;"></textarea>';
            
            const textarea = document.getElementById('fallback-editor');
            if (textarea) {
                textarea.value = getDefaultCode();
                
                // Create minimal editor interface
                window.editor = {
                    setValue: (code) => { textarea.value = code; },
                    getValue: () => textarea.value,
                    getModel: () => ({ setValue: (code) => textarea.value = code }),
                    layout: () => {},
                    focus: () => textarea.focus(),
                    setPosition: () => {},
                    onDidChangeModelContent: (callback) => {
                        textarea.addEventListener('input', callback);
                        return { dispose: () => {} };
                    }
                };
                
                window.monacoEditor = window.editor;
                window.codeEditor = window.editor;
                
                // Auto-save on changes
                textarea.addEventListener('input', () => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Mark as ready
                window.editorReady = true;
                console.log('✅ Fallback editor ready for injection');
                
                // Initialize Three.js
                initializeThreeJS();
            }
        }
        
        // Initialize Three.js with comprehensive error handling
        function initializeThreeJS() {
            console.log('🚀 Initializing Three.js...');
            
            try {
                // Check if THREE is available
                if (typeof THREE === 'undefined') {
                    console.error('❌ CRITICAL: THREE.js library not loaded from CDN');
                    throw new Error('THREE.js library not loaded - check network connection');
                }
                
                canvas = document.getElementById('renderCanvas');
                if (!canvas) {
                    console.error('❌ CRITICAL: Canvas element not found in DOM');
                    throw new Error('Canvas element not found');
                }
                
                console.log('✅ Canvas found:', canvas.clientWidth + 'x' + canvas.clientHeight);
                console.log('✅ THREE.js version available:', THREE.REVISION);
                
                // Create renderer with error handling
                console.log('🎨 Creating WebGL renderer...');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    preserveDrawingBuffer: true
                });
                
                const canvasWidth = canvas.clientWidth || 800;
                const canvasHeight = canvas.clientHeight || 600;
                renderer.setSize(canvasWidth, canvasHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                console.log('✅ Three.js renderer created successfully:', canvasWidth + 'x' + canvasHeight);
                
                // Test renderer capabilities
                const gl = renderer.getContext();
                if (!gl) {
                    console.error('❌ CRITICAL: WebGL context not available');
                    throw new Error('WebGL not supported');
                }
                console.log('✅ WebGL context created successfully');
                
            } catch (rendererError) {
                console.error('❌ CRITICAL: Three.js renderer creation failed:', rendererError);
                console.error('❌ Error stack:', rendererError.stack);
                return; // Don't continue if renderer fails
            }
            
            try {
                // Create default scene and camera
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, (canvas.clientWidth || 800) / (canvas.clientHeight || 600), 0.1, 1000);
                console.log('✅ Scene and camera created');
            } catch (sceneError) {
                console.error('❌ Scene/camera creation failed:', sceneError);
                return;
            }
            
            // Set up camera position and create mock controls
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Create mock controls object to prevent undefined errors
            controls = {
                target: { x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; } },
                update: function() {},
                enableDamping: false,
                dampingFactor: 0.05
            };
            
            console.log('✅ Camera positioned with mock controls');
            
            // Make globals available
            window.canvas = canvas;
            window.renderer = renderer;
            window.scene = scene;
            window.camera = camera;
            window.controls = controls;
            window.THREE = THREE;
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start render loop BEFORE creating default scene
            startRenderLoop();
            
            // Create default scene AND run it automatically
            console.log('🎯 Auto-running default scene on initialization...');
            createDefaultScene();
            
            console.log('Three.js initialization complete');
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Three.js playground fully initialized');
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!renderer 
                });
            }, 1500);
        }
        
        function startRenderLoop() {
            console.log('🎬 Starting Three.js render loop...');
            let frameCount = 0;
            
            function animate() {
                animationId = requestAnimationFrame(animate);
                frameCount++;
                
                // Debug every 60 frames (about once per second at 60fps)
                if (frameCount % 60 === 0) {
                    console.log('🎬 Render loop active, frame:', frameCount, 'scene children:', scene?.children?.length || 0);
                }
                
                controls.update();
                
                // Execute any scene animations
                if (scene && scene.userData && scene.userData.animate) {
                    scene.userData.animate();
                }
                
                if (scene && camera && renderer) {
                    renderer.render(scene, camera);
                } else if (frameCount < 10) {
                    console.log('⚠️ Missing components - scene:', !!scene, 'camera:', !!camera, 'renderer:', !!renderer);
                }
            }
            animate();
        }
        
        function onWindowResize() {
            if (camera && renderer && canvas) {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }
        
        function getDefaultCode() {
            return `// Welcome to Three.js Playground!
// Create your 3D scene using Three.js r160+

const createScene = () => {
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x606060); // Even lighter background for better visibility
    
    // Create camera (use canvas dimensions for proper aspect ratio)
    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting - Enhanced for better visibility
    const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // Increased ambient intensity
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Full intensity
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Add point light for additional illumination
    const pointLight = new THREE.PointLight(0xffffff, 0.5, 50);
    pointLight.position.set(-10, 10, -10);
    scene.add(pointLight);
    
    // Create geometry and material
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.y = 1;
    scene.add(sphere);
    
    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(10, 10);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    // Set up controls
    controls.target.set(0, 0, 0);
    controls.update();
    
    console.log("Scene created with camera:", !!camera, "objects:", scene.children.length);
    
    return { scene, camera };
};

// Execute the scene creation and update global references
const sceneResult = createScene();
if (sceneResult && sceneResult.scene) {
    window.scene = sceneResult.scene;
    scene = sceneResult.scene;
}
if (sceneResult && sceneResult.camera) {
    window.camera = sceneResult.camera;
    camera = sceneResult.camera;
}

console.log("✅ Default scene creation complete!");`;
        }
        
        function createDefaultScene() {
            try {
                console.log('🎯 createDefaultScene called...');
                
                // Get current editor code or fall back to default
                const codeToRun = editor ? editor.getValue() : getDefaultCode();
                const isDefaultCode = !editor || editor.getValue() === getDefaultCode();
                
                console.log('🎯 Running code:', isDefaultCode ? 'DEFAULT CODE' : 'EDITOR CONTENT');
                console.log('🎯 Code length:', codeToRun.length);
                
                // Execute the code (this handles scene replacement)
                executeUserCode(codeToRun);
                
                hideError();
            } catch (error) {
                console.error('❌ createDefaultScene failed:', error);
                showError('Scene Creation Error: ' + error.message);
                
                // Create emergency fallback scene
                createFallbackScene();
            }
        }
        
        function clearScene() {
            if (scene) {
                console.log('🧹 Clearing scene objects (preserving lighting)...');
                
                // Only remove non-light objects to preserve lighting
                const objectsToRemove = [];
                
                // Collect non-light objects
                scene.children.forEach(child => {
                    if (!(child instanceof THREE.Light) && 
                        !child.isAmbientLight && 
                        !child.isDirectionalLight && 
                        !child.isPointLight && 
                        !child.isSpotLight && 
                        !child.isHemisphereLight) {
                        objectsToRemove.push(child);
                    }
                });
                
                // Remove and dispose non-light objects
                objectsToRemove.forEach(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                if (mat.map) mat.map.dispose();
                                mat.dispose();
                            });
                        } else {
                            if (object.material.map) object.material.map.dispose();
                            object.material.dispose();
                        }
                    }
                    scene.remove(object);
                });
                
                console.log('✅ Scene cleared, lights preserved:', scene.children.length, 'objects remaining');
            }
        }
        
        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING THREE.JS USER CODE ===');
                
                clearConsole();
                
                // Store old scene and camera for comparison
                const oldScene = scene;
                const oldCamera = camera;
                
                // Clear existing objects but preserve lighting
                clearScene();
                
                // Execute the code in global context
                const executeCode = new Function('THREE', 'scene', 'camera', 'renderer', 'controls', 'canvas',
                    `try {
                        ${code}
                        
                        // Check if code created a new scene vs modifying existing
                        let resultScene = window.scene || scene;
                        let resultCamera = window.camera || camera;
                        
                        // If user code creates its own scene, use that
                        if (typeof createScene === 'function') {
                            const sceneResult = createScene();
                            if (sceneResult && sceneResult.scene) {
                                resultScene = sceneResult.scene;
                                resultCamera = sceneResult.camera || camera;
                            } else if (sceneResult && sceneResult.constructor === THREE.Scene) {
                                resultScene = sceneResult;
                            }
                        }
                        
                        return { scene: resultScene, camera: resultCamera };
                    } catch (execError) {
                        console.error('Code execution error:', execError);
                        throw execError;
                    }`
                );
                
                const result = executeCode(THREE, scene, camera, renderer, controls, canvas);
                
                // Handle scene replacement
                if (result && result.scene && result.scene !== oldScene) {
                    console.log('🔄 Replacing scene with new one');
                    scene = result.scene;
                    window.scene = result.scene;
                } else if (result && result.scene) {
                    console.log('🔧 Using modified existing scene');
                    scene = result.scene;
                    window.scene = result.scene;
                }
                
                // Handle camera replacement
                if (result && result.camera && result.camera !== oldCamera) {
                    console.log('📷 Replacing camera with new one');
                    camera = result.camera;
                    window.camera = result.camera;
                } else if (result && result.camera) {
                    camera = result.camera;
                    window.camera = result.camera;
                }
                
                // Ensure renderer uses correct canvas dimensions (fix common user error)
                const canvasWidth = canvas.clientWidth || 800;
                const canvasHeight = canvas.clientHeight || 600;
                renderer.setSize(canvasWidth, canvasHeight);
                
                // Fix camera aspect ratio if needed
                if (camera && camera.isPerspectiveCamera) {
                    camera.aspect = canvasWidth / canvasHeight;
                    camera.updateProjectionMatrix();
                }
                
                console.log('✅ Three.js scene created successfully');
                console.log('🎯 Renderer size:', renderer.getSize(new THREE.Vector2()));
                console.log('🎯 Canvas size:', canvas.clientWidth + 'x' + canvas.clientHeight);
                console.log('🎯 Scene children:', scene.children.length);
                console.log('🎯 Camera position:', camera.position);
                console.log('🎯 Scene background:', scene.background);
                console.log('🎯 Render loop running:', !!animationId);
                
                // Log scene composition for debugging
                if (scene.children.length > 0) {
                    console.log('🎯 Scene objects:', scene.children.map(child => child.constructor.name).join(', '));
                    const lightCount = scene.children.filter(child => child instanceof THREE.Light).length;
                    const meshCount = scene.children.filter(child => child instanceof THREE.Mesh).length;
                    console.log(`🎯 Scene composition: ${lightCount} lights, ${meshCount} meshes`);
                }
                
                // Force an immediate render to test
                if (scene && camera && renderer) {
                    console.log('🎯 Forcing immediate render test...');
                    renderer.render(scene, camera);
                }
                
                hideError();
                
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('❌ executeUserCode failed:', errorMsg);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Create fallback scene
                createFallbackScene();
            }
        }
        
        function createFallbackScene() {
            console.log('🚨 Creating Three.js EMERGENCY fallback scene...');
            
            try {
                clearScene();
                
                // Recreate scene and camera with global assignment
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x606060); // Light background for visibility
                
                camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
                
                // Enhanced lighting for fallback scene
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.5, 50);
                pointLight.position.set(-10, 10, -10);
                scene.add(pointLight);
                
                // Create bright green sphere for visibility
                const geometry = new THREE.SphereGeometry(1, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.y = 1;
                scene.add(sphere);
                
                // Add ground plane
                const groundGeometry = new THREE.PlaneGeometry(10, 10);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                scene.add(ground);
                
                // Set controls
                controls.target.set(0, 0, 0);
                controls.update();
                
                // Update global references
                window.scene = scene;
                window.camera = camera;
                
                console.log('✅ Fallback scene created with objects:', scene.children.length);
                console.log('✅ Fallback camera position:', camera.position);
                
                // Force immediate render
                if (renderer) {
                    renderer.render(scene, camera);
                    console.log('✅ Fallback scene rendered immediately');
                }
                
            } catch (fallbackError) {
                console.error('❌ CRITICAL: Even fallback scene creation failed:', fallbackError);
            }
        }
        
        // Playground functions
        function runCode() {
            console.log('🚀 Run code button pressed - executing current editor content');
            
            try {
                // Get current code from editor
                const currentCode = editor ? editor.getValue() : getDefaultCode();
                console.log('🎯 Executing code with length:', currentCode.length);
                
                // Execute the current code (this will replace the scene)
                executeUserCode(currentCode);
                
                notifySwift('codeRun', { success: true });
            } catch (error) {
                console.error('❌ runCode failed:', error);
                showError('Run Error: ' + error.message);
                notifySwift('codeRun', { success: false, error: error.message });
            }
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function showExamples() {
            notifySwift('showExamples', {});
        }
        
        function toggleConsole() {
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay.style.display === 'none' || !consoleDisplay.style.display) {
                updateConsoleDisplay();
                if (consoleMessages.length === 0) {
                    console.log('Console opened - no messages yet');
                }
                console.log('📺 Console is now visible (positioned over canvas area)');
            } else {
                consoleDisplay.style.display = 'none';
                console.log('📺 Console hidden');
            }
        }
        
        // Show console by default for debugging
        setTimeout(() => {
            console.log('🔧 Auto-showing console for debugging...');
            toggleConsole();
        }, 2000);
        
        function loadExample(exampleId) {
            if (!exampleId) return;
            
            const examples = {
                'basic-scene': getDefaultCode(),
                'rotating-cube': getRotatingCubeCode(),
                'lighting': getLightingDemoCode(),
                'materials': getMaterialsDemoCode()
            };
            
            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion functions with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('🎯 insertCodeAtCursor called with code length:', codeString.length);
            console.log('🔍 Three.js editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('✅ Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('✅ Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('❌ Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('⚠️ Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        // setFullEditorContent function already defined above
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management functions already defined above
        
        // Example code templates
        function getRotatingCubeCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Create rotating cube
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshPhongMaterial({ color: 0xff6b35 });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.y = 1;
    scene.add(cube);
    
    // Animation
    function animate() {
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
    }
    
    // Register animation
    scene.userData.animate = animate;
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
        
        function getLightingDemoCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Multiple lights
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0xff6b35, 1, 100);
    pointLight.position.set(-5, 5, 5);
    scene.add(pointLight);
    
    // Objects
    const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.set(-2, 1, 0);
    scene.add(sphere);
    
    const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
    const boxMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b35 });
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    box.position.set(2, 1, 0);
    scene.add(box);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
        
        function getMaterialsDemoCode() {
            return `const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Different materials
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    
    // Basic material
    const basicMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const basicSphere = new THREE.Mesh(geometry, basicMaterial);
    basicSphere.position.set(-3, 1, 0);
    scene.add(basicSphere);
    
    // Phong material
    const phongMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x00ff00,
        shininess: 100
    });
    const phongSphere = new THREE.Mesh(geometry, phongMaterial);
    phongSphere.position.set(0, 1, 0);
    scene.add(phongSphere);
    
    // Standard material
    const standardMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0000ff,
        metalness: 0.5,
        roughness: 0.1
    });
    const standardSphere = new THREE.Mesh(geometry, standardMaterial);
    standardSphere.position.set(3, 1, 0);
    scene.add(standardSphere);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();`;
        }
    </script>
</body>
</html>