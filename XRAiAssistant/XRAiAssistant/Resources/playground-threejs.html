<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Playground</title>
    
    <!-- Three.js Core -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <!-- Three.js Controls -->
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
        }
        
        .header {
            background: #2d2d30;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #3e3e42;
            min-height: 40px;
        }
        
        .menu-btn {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .menu-btn:hover {
            background: #ff8c1a;
        }
        
        .menu-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .editor-container {
            width: 50%;
            background: #1e1e1e;
            border-right: 1px solid #3e3e42;
            position: relative;
        }
        
        .canvas-container {
            width: 50%;
            background: #252526;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
            display: block;
        }
        
        .resize-handle {
            position: absolute;
            top: 0;
            right: -2px;
            width: 4px;
            height: 100%;
            background: #3e3e42;
            cursor: col-resize;
            z-index: 10;
        }
        
        .resize-handle:hover {
            background: #ff6b35;
        }
        
        .footer {
            background: #ff6b35;
            padding: 4px 12px;
            font-size: 11px;
            text-align: center;
            color: white;
        }
        
        .error-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f14c4c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        
        .console-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            color: #ccc;
            padding: 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            border: 1px solid #3e3e42;
        }
        
        .console-message {
            margin: 2px 0;
            word-wrap: break-word;
        }
        
        .console-error {
            color: #f14c4c;
        }
        
        .console-warning {
            color: #ffcc02;
        }
        
        .console-log {
            color: #ccc;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #cccccc;
            font-size: 14px;
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .editor-container {
                width: 100%;
                height: 50%;
                border-right: none;
                border-bottom: 1px solid #3e3e42;
            }
            
            .canvas-container {
                width: 100%;
                height: 50%;
            }
            
            .resize-handle {
                top: -2px;
                right: 0;
                width: 100%;
                height: 4px;
                cursor: row-resize;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-btn" onclick="runCode()">â–¶ Run</button>
        <button class="menu-btn" onclick="formatCode()">{ } Format</button>
        <button class="menu-btn" onclick="clearCode()">ðŸ—‘ Clear</button>
        <button class="menu-btn" onclick="saveScene()">ðŸ’¾ Save</button>
        <button class="menu-btn" onclick="downloadScene()">â¬‡ Download</button>
        <button class="menu-btn" onclick="newScene()">ðŸ“„ New</button>
        <button class="menu-btn" onclick="showExamples()">ðŸ“š Examples</button>
        <button class="menu-btn" onclick="toggleConsole()">ðŸ–¥ Console</button>
        <select class="menu-btn" onchange="loadExample(this.value)">
            <option value="">Select Example...</option>
            <option value="basic-scene">Basic Scene</option>
            <option value="rotating-cube">Rotating Cube</option>
            <option value="lighting">Lighting Demo</option>
            <option value="materials">Materials Demo</option>
        </select>
    </div>
    
    <div class="main-container">
        <div class="editor-container">
            <div id="monaco-editor" style="width: 100%; height: 100%;"></div>
            <div class="resize-handle"></div>
        </div>
        <div class="canvas-container">
            <canvas id="renderCanvas"></canvas>
            <div class="loading" id="loading">Loading Three.js...</div>
        </div>
    </div>
    
    <div class="footer">
        Three.js Playground - Powered by WebGL
    </div>
    
    <div class="error-display" id="errorDisplay"></div>
    <div class="console-display" id="consoleDisplay"></div>

    <script>
        let editor;
        let renderer;
        let scene;
        let camera;
        let controls;
        let canvas;
        let animationId;
        let isResizing = false;
        let consoleMessages = [];
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };
        
        console.log = (...args) => {
            originalConsole.log(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        console.error = (...args) => {
            originalConsole.error(...args);
            addConsoleMessage('error', args.map(arg => String(arg)).join(' '));
        };
        
        console.warn = (...args) => {
            originalConsole.warn(...args);
            addConsoleMessage('warning', args.map(arg => String(arg)).join(' '));
        };
        
        console.info = (...args) => {
            originalConsole.info(...args);
            addConsoleMessage('log', args.map(arg => String(arg)).join(' '));
        };
        
        // Initialize Monaco Editor
        console.log('Starting Monaco Editor initialization...');
        require.config({ paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' } });
        require(['vs/editor/editor.main'], function () {
            console.log('Monaco modules loaded, creating editor...');
            
            try {
                editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                    value: getDefaultCode(),
                    language: 'javascript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    renderLineHighlight: 'all',
                    selectionHighlight: false,
                    lineNumbers: 'on',
                    glyphMargin: true,
                    folding: true,
                    foldingStrategy: 'indentation',
                    showFoldingControls: 'always',
                    unfoldOnClickAfterEndOfLine: false,
                    tabSize: 4
                });
                
                console.log('âœ… Monaco editor created successfully:', !!editor);
                
                // Auto-save on changes
                editor.onDidChangeModelContent(() => {
                    debounce(notifyCodeChange, 500)();
                });
                
                // Make editor globally accessible
                window.editor = editor;
                window.monacoEditor = editor;
                window.codeEditor = editor;
                
                setTimeout(() => {
                    console.log('ðŸ“ Monaco editor ready for Three.js');
                    window.editorReady = true;
                    console.log('ðŸŽ¯ MONACO EDITOR MARKED AS READY FOR INJECTION');
                    
                    initializeThreeJS();
                }, 1000);
                
            } catch (error) {
                console.error('âŒ Failed to create Monaco editor:', error);
                initializeThreeJS();
            }
            
        }, function(error) {
            console.error('âŒ Failed to load Monaco modules:', error);
            initializeThreeJS();
        });
        
        // Initialize Three.js
        function initializeThreeJS() {
            console.log('Initializing Three.js...');
            
            canvas = document.getElementById('renderCanvas');
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            console.log('Three.js renderer created');
            
            // Create default scene and camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            
            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Make globals available
            window.canvas = canvas;
            window.renderer = renderer;
            window.scene = scene;
            window.camera = camera;
            window.controls = controls;
            window.THREE = THREE;
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Create default scene
            createDefaultScene();
            
            // Start render loop
            startRenderLoop();
            
            console.log('Three.js initialization complete');
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            
            // Notify Swift that initialization is complete
            setTimeout(() => {
                console.log('Three.js playground fully initialized');
                notifySwift('initializationComplete', { 
                    ready: true,
                    editorReady: !!(window.editorReady && typeof editor !== 'undefined' && editor),
                    engineReady: !!renderer 
                });
            }, 1500);
        }
        
        function startRenderLoop() {
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                controls.update();
                
                if (scene && camera && renderer) {
                    renderer.render(scene, camera);
                }
            }
            animate();
        }
        
        function onWindowResize() {
            if (camera && renderer && canvas) {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }
        
        function getDefaultCode() {
            return `// Welcome to Three.js Playground!
// Create your 3D scene using Three.js r160+

const createScene = () => {
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Create geometry and material
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.y = 1;
    scene.add(sphere);
    
    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(10, 10);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    // Set up controls
    controls.target.set(0, 0, 0);
    controls.update();
    
    console.log("Scene created with camera:", !!camera, "objects:", scene.children.length);
    
    return { scene, camera };
};

// Execute the scene creation
const { scene, camera } = createScene();`;
        }
        
        function createDefaultScene() {
            try {
                // Clear existing scene
                clearScene();
                
                // Execute user code
                const userCode = editor ? editor.getValue() : getDefaultCode();
                executeUserCode(userCode);
                
                hideError();
            } catch (error) {
                showError('Scene Creation Error: ' + error.message);
                console.error('Scene creation error:', error);
            }
        }
        
        function clearScene() {
            if (scene) {
                // Remove all objects from scene
                while(scene.children.length > 0) {
                    const object = scene.children[0];
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (object.material.map) object.material.map.dispose();
                        object.material.dispose();
                    }
                    scene.remove(object);
                }
            }
        }
        
        function executeUserCode(code) {
            try {
                console.log('=== EXECUTING THREE.JS USER CODE ===');
                
                clearConsole();
                clearScene();
                
                // Execute the code in global context
                const executeCode = new Function('THREE', 'scene', 'camera', 'renderer', 'controls', 'canvas',
                    \`try {
                        \${code}
                        return { scene: window.scene || scene, camera: window.camera || camera };
                    } catch (execError) {
                        console.error('Code execution error:', execError);
                        throw execError;
                    }\`
                );
                
                const result = executeCode(THREE, scene, camera, renderer, controls, canvas);
                
                if (result && result.scene) {
                    window.scene = result.scene;
                    scene = result.scene;
                }
                if (result && result.camera) {
                    window.camera = result.camera;
                    camera = result.camera;
                }
                
                console.log('âœ… Three.js scene created successfully');
                hideError();
                
                notifySwift('sceneCreated', { success: true });
                
            } catch (error) {
                const errorMsg = 'Execution Error: ' + error.message;
                console.error('âŒ executeUserCode failed:', errorMsg);
                showError(errorMsg);
                notifySwift('sceneError', { error: error.message });
                
                // Create fallback scene
                createFallbackScene();
            }
        }
        
        function createFallbackScene() {
            console.log('Creating Three.js fallback scene');
            clearScene();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            const light = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(light);
            
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            controls.target.set(0, 0, 0);
            controls.update();
            
            window.scene = scene;
            window.camera = camera;
        }
        
        // Playground functions
        function runCode() {
            console.log('Run code button pressed');
            createDefaultScene();
            notifySwift('codeRun', {});
        }
        
        function formatCode() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
                notifySwift('codeFormatted', {});
            }
        }
        
        function clearCode() {
            if (editor) {
                editor.setValue(getDefaultCode());
                notifySwift('codeCleared', {});
            }
        }
        
        function saveScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('saveRequested', { code: code });
        }
        
        function downloadScene() {
            const code = editor ? editor.getValue() : '';
            notifySwift('downloadRequested', { code: code });
        }
        
        function newScene() {
            clearCode();
            runCode();
        }
        
        function showExamples() {
            notifySwift('showExamples', {});
        }
        
        function toggleConsole() {
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleDisplay.style.display === 'none' || !consoleDisplay.style.display) {
                updateConsoleDisplay();
                if (consoleMessages.length === 0) {
                    console.log('Console opened - no messages yet');
                }
            } else {
                consoleDisplay.style.display = 'none';
            }
        }
        
        function loadExample(exampleId) {
            if (!exampleId) return;
            
            const examples = {
                'basic-scene': getDefaultCode(),
                'rotating-cube': getRotatingCubeCode(),
                'lighting': getLightingDemoCode(),
                'materials': getMaterialsDemoCode()
            };
            
            if (examples[exampleId] && editor) {
                editor.setValue(examples[exampleId]);
                runCode();
            }
        }
        
        // Enhanced code insertion functions with multi-level fallback
        function insertCodeAtCursor(codeString) {
            console.log('ðŸŽ¯ insertCodeAtCursor called with code length:', codeString.length);
            console.log('ðŸ” Three.js editor readiness:', {
                editor: !!editor,
                editorReady: !!window.editorReady,
                monacoLoaded: typeof monaco !== 'undefined'
            });
            
            if (editor && window.editorReady) {
                try {
                    console.log('âœ… Editor ready, inserting at cursor');
                    const position = editor.getPosition();
                    editor.executeEdits('ai-insertion', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: codeString
                    }]);
                    editor.setPosition(position);
                    editor.focus();
                    console.log('âœ… Code inserted at cursor position');
                    notifySwift('codeInserted', { code: codeString });
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to insert at cursor:', error);
                    // Fall back to setFullEditorContent
                    return setFullEditorContent(codeString);
                }
            } else {
                console.warn('âš ï¸ Editor not ready for cursor insertion, falling back to full content replacement');
                return setFullEditorContent(codeString);
            }
        }
        
        function setFullEditorContent(codeString) {
            console.log('ðŸŽ¯ Three.js setFullEditorContent called with code length:', codeString.length);
            console.log('ðŸ” Three.js editor state check:', {
                editorExists: !!editor,
                editorReady: !!window.editorReady,
                domReady: document.readyState,
                monacoGlobal: typeof monaco !== 'undefined'
            });
            
            // Multi-level injection strategy for Three.js
            const strategies = [
                // Strategy 1: Standard Monaco API
                () => {
                    if (editor && window.editorReady && typeof editor.setValue === 'function') {
                        console.log('ðŸ“ Three.js Strategy 1: Using standard Monaco setValue');
                        editor.setValue(codeString);
                        editor.focus();
                        editor.setPosition({lineNumber: 1, column: 1});
                        editor.layout();
                        
                        // Verify content was set
                        const verification = editor.getValue();
                        if (verification === codeString) {
                            console.log('âœ… Three.js Strategy 1 successful - content verified');
                            return true;
                        } else {
                            console.warn('âš ï¸ Three.js Strategy 1 verification failed');
                            return false;
                        }
                    }
                    return false;
                },
                
                // Strategy 2: Direct model manipulation
                () => {
                    if (editor && editor.getModel && typeof editor.getModel === 'function') {
                        console.log('ðŸ“ Three.js Strategy 2: Using Monaco model setValue');
                        const model = editor.getModel();
                        if (model && typeof model.setValue === 'function') {
                            model.setValue(codeString);
                            editor.focus();
                            console.log('âœ… Three.js Strategy 2 successful - model setValue');
                            return true;
                        }
                    }
                    return false;
                },
                
                // Strategy 3: Emergency retry with delay
                () => {
                    return new Promise((resolve) => {
                        console.log('ðŸ“ Three.js Strategy 3: Emergency retry with delay');
                        setTimeout(() => {
                            if (editor && typeof editor.setValue === 'function') {
                                try {
                                    editor.setValue(codeString);
                                    console.log('âœ… Three.js Strategy 3 successful - delayed retry');
                                    resolve(true);
                                } catch (e) {
                                    console.error('âŒ Three.js Strategy 3 failed:', e);
                                    resolve(false);
                                }
                            } else {
                                resolve(false);
                            }
                        }, 1000);
                    });
                }
            ];
            
            // Try each strategy sequentially
            const executeStrategies = async () => {
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        const result = await strategies[i]();
                        if (result) {
                            console.log(`ðŸŽ‰ Three.js content injection successful using strategy ${i + 1}`);
                            
                            // Auto-run the code after successful injection
                            setTimeout(() => {
                                console.log('ðŸš€ Auto-running the injected Three.js code...');
                                runCode();
                            }, 500);
                            
                            notifySwift('codeInserted', { 
                                code: codeString,
                                strategy: i + 1,
                                success: true,
                                library: 'threejs'
                            });
                            return true;
                        }
                    } catch (error) {
                        console.error(`âŒ Three.js Strategy ${i + 1} failed:`, error);
                    }
                }
                
                console.error('âŒ All Three.js injection strategies failed');
                notifySwift('codeInserted', { 
                    code: codeString,
                    success: false,
                    error: 'All Three.js injection strategies failed',
                    library: 'threejs'
                });
                return false;
            };
            
            return executeStrategies();
        }
        
        // Utility functions
        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }
        
        function hideError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function notifySwift(action, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                window.webkit.messageHandlers.playgroundHandler.postMessage({
                    action: action,
                    data: data
                });
            }
        }
        
        function notifyCodeChange() {
            const code = editor ? editor.getValue() : '';
            notifySwift('codeChanged', { code: code });
        }
        
        // Console management
        function addConsoleMessage(type, message) {
            consoleMessages.push({ type, message, timestamp: Date.now() });
            if (consoleMessages.length > 50) {
                consoleMessages = consoleMessages.slice(-50);
            }
            updateConsoleDisplay();
        }
        
        function updateConsoleDisplay() {
            const consoleDisplay = document.getElementById('consoleDisplay');
            if (consoleMessages.length > 0) {
                consoleDisplay.innerHTML = consoleMessages.map(msg => 
                    \`<div class="console-message console-\${msg.type}">\${escapeHtml(msg.message)}</div>\`
                ).join('');
                consoleDisplay.style.display = 'block';
                consoleDisplay.scrollTop = consoleDisplay.scrollHeight;
            } else {
                consoleDisplay.style.display = 'none';
            }
        }
        
        function clearConsole() {
            consoleMessages = [];
            updateConsoleDisplay();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Example code templates
        function getRotatingCubeCode() {
            return \`const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Create rotating cube
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshPhongMaterial({ color: 0xff6b35 });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.y = 1;
    scene.add(cube);
    
    // Animation
    function animate() {
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
    }
    
    // Register animation
    scene.userData.animate = animate;
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();\`;
        }
        
        function getLightingDemoCode() {
            return \`const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Multiple lights
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0xff6b35, 1, 100);
    pointLight.position.set(-5, 5, 5);
    scene.add(pointLight);
    
    // Objects
    const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.set(-2, 1, 0);
    scene.add(sphere);
    
    const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
    const boxMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b35 });
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    box.position.set(2, 1, 0);
    scene.add(box);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();\`;
        }
        
        function getMaterialsDemoCode() {
            return \`const createScene = () => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    // Different materials
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    
    // Basic material
    const basicMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const basicSphere = new THREE.Mesh(geometry, basicMaterial);
    basicSphere.position.set(-3, 1, 0);
    scene.add(basicSphere);
    
    // Phong material
    const phongMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x00ff00,
        shininess: 100
    });
    const phongSphere = new THREE.Mesh(geometry, phongMaterial);
    phongSphere.position.set(0, 1, 0);
    scene.add(phongSphere);
    
    // Standard material
    const standardMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0000ff,
        metalness: 0.5,
        roughness: 0.1
    });
    const standardSphere = new THREE.Mesh(geometry, standardMaterial);
    standardSphere.position.set(3, 1, 0);
    scene.add(standardSphere);
    
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    controls.target.set(0, 0, 0);
    controls.update();
    
    return { scene, camera };
};

const { scene, camera } = createScene();\`;
        }
    </script>
</body>
</html>